---
title : Redis 数据类型与适用场景
description : Redis 数据类型与适用场景
tags:
 - redis
date: 2020-03-04
categories:
 - web
 - redis
weight: 4
---

redis 常被拿来与 memcached 来比较，但非常不通的地方就在于 Redis 有非常出色的数据结构，使用非常简便。
本文介绍常用的数据类型和使用场景 Strings Lists Hashes Sets Sorted-Sets 等。
<!--more-->

# 数据类型

## Strings

字符串是Redis值中最基本的一种。 
Redis字符串是二进制安全的，这意味着Redis字符串可以包含任何类型的数据，例如JPEG图像或序列化的Ruby对象。

字符串值的最大长度为512 MB。

使用场景：
* 使用INCR系列中的命令将字符串用作原子计数器：INCR，DECR，INCRBY。
* 使用APPEND命令附加到字符串。
* 使用字符串作为带有GETRANGE和SETRANGE的随机访问向量。
* 在很小的空间内编码大量数据，或使用GETBIT和SETBIT创建Redis支持的Bloom Filter。
* 会话缓存：许多网站利用Redis字符串创建会话缓存，以通过缓存HTML片段或页面来加快其网站体验。由于数据是临时存储在RAM中的，因此此属性使Redis成为会话缓存的理想选择。它能够临时存储特定于用户的数据，例如在线商店中购物车中存储的项目，这一点至关重要，因为您的用户在注销或失去连接时不会丢失其数据。PHP的缓存甚至可以直接在配置文件中指定存储到redis。


## Lists

Redis列表只是字符串列表，按插入顺序排序。可以将元素添加到Redis列表中，从而将新元素推到列表的顶部（左侧）或结尾（右侧）。

最大支持 2^32 - 1 个元素， 4294967295 40亿

使用场景：
* 在社交网络中对时间轴建模，请使用LPUSH以便在用户时间轴中添加新元素，并使用LRANGE来检索一些最近插入的项目
* 可以将LPUSH与LTRIM一起使用，以创建一个列表，该列表从不超过给定数量的元素，而只记住最新的N个元素
* 列表可以用作消息传递，用作跨系统的数据载体
* 可以使用列表做更多的事情，此数据类型支持许多命令，包括阻塞命令，例如BLPOP

## Sets


Redis集是字符串的无序集合。添加，删除和测试成员的存在 O(1) 复杂度。（恒定时间，与Set中包含的元素数量无关）。  
Redis集具有不允许重复成员的理想属性。多次添加同一元素将导致集合具有该元素的单个副本。实际上，这意味着添加成员不需要检查是否存在，然后进行添加操作。  
可以在很短的时间内完成集的相交，交集，差集。

最大支持 2^32 - 1 个元素， 4294967295 40亿

使用场景：
* 使用Redis集来跟踪独特的事物， 比如UV，根据IP去重。想知道访问给定博客帖子的所有唯一IP地址吗？每次处理页面视图时，只需使用SADD。您确定不会插入重复的IP。
* Redis Set 很好地表示关系。您可以使用Set代表每个标签，使用Redis创建标签系统。然后，可以使用SADD命令将具有给定标签的所有对象的所有ID添加到代表该特定标签的Set中。您是否希望所有对象的所有ID同时具有三个不同的标签？只需使用SINTER。
* 您可以使用 Set 使用 SPOP 或 SRANDMEMBER 命令随机提取元素。


## Hashes

Redis Hashes 是字符串字段和字符串值之间的映射，因此它们是表示对象的理想数据类型（例如，具有多个字段（例如名称，姓氏，年龄等）的User）：

    @cli
    HMSET user:1000 username antirez password P1pp0 age 34
    HGETALL user:1000
    HSET user:1000 password 12345
    HGETALL user:1000

具有几个字段（官方建议大概最多一百个左右）的散列以占用很少空间的方式存储，因此您可以在小型Redis实例中存储数百万个对象。  
尽管哈希主要用于表示对象，但是它们能够存储许多元素，因此您也可以将哈希用于许多其他任务。  
每个哈希最多可以存储2 ^ 32-1个字段-值对（超过40亿个）

使用场景：
* 缓存用户信息
* 可以相似的多个 String 用 Hashes 汇集在一起

## Sorted sets

与Redis集类似，Redis排序集是非重复的String集合。区别在于，排序集的每个成员都与Score相关联，该得分用于从最小到最大得分中获取排序的排序集。虽然成员是唯一的，但分数可能会重复。

使用排序集，您可以非常快速地添加 O(log(N))，删除 O(M*log(N)) 或更新元素（时间与元素数量的对数成正比）。  
由于元素是按顺序排序的，因此可以非常快速地按分数或按排名（位置）获得范围。  
访问排序集的中间位置也非常快，因此您可以将排序集用作非重复元素的智能列表，  
从中可以快速访问所需的所有内容：元素的顺序，快速检测元素是否存在，对中间元素的快速访问。

简而言之，使用Sorted Sets，可以执行许多性能出色的任务，而这些任务实际上很难在其他类型的数据库中建模。  
比如：

* 积分排行版，使用 ZADD 来更新元素的分值， ZRANGE 来获取范围分值的数据，ZRANK 查找排行，时间复杂度都是 O(log(N)+M) ,速度很快

* Sorted Sets 通常用于索引Redis中存储的数据。例如，如果您有许多代表用户的哈希，则可以使用已排序的集合，其元素具有用户的年龄作为得分，而用户的ID作为值。因此，使用ZRANGEBYSCORE检索具有给定年龄段的所有用户将非常简单快捷。

* Sorted Set 还可用作为延迟队列，使用 时间戳 作为score， ZRANGEBYSCORE 来查找符合时间范围的数据，并且再消费完成以后，使用 ZREMRANGEBYSCORE 来删除这部分数据


## Bitmaps 

Bitmaps and HyperLogLogs 实际上是基于 String 类型，但是他们有自己的语意

Bitmaps 支持如下几个操作：  
BITCOUNT BITFIELD BITOP BITPOS GETBIT and SETBIT

Bitmaps 是某些类型信息的非常节省空间的表示形式。
一个示例是需要用户访问历史的Web应用程序，因此例如可以确定哪些用户是beta功能的良好目标。


使用场景：
* 制作快速，简便，实时的指标
* 每日活跃用户，每日一个key，根据用户ID对 redis key 的偏移位进行置1，
* 



## HyperLogLogs

Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。

类似 set 计算值基数集的数量，但是不能返回具体的元素。

一边 ADD 一边计算， 所以在使用 PFCOUNT 的时候，只是取一个值，并未进行计算所以复杂度是 O(1)

当用单个键调用PFCOUNT时，即使在理论上处理密集型HyperLogLog的恒定时间很高，性能也很出色。这是可能的，因为PFCOUNT使用缓存来记住先前计算的基数，这种变化很少改变，因为大多数PFADD操作不会更新任何寄存器。每秒可能进行数百次操作。

当使用多个键调用PFCOUNT时，会执行HyperLogLogs的即时合并，这很慢，而且无法缓存联合的基数，因此当与多个键一起使用时，PFCOUNT可能会花费一些时间。一个毫秒级的数量级，不应滥用。

用户应记住，PFCOUNT 命令的单key和多keys执行在语义上是不同的，并且具有不同的性能。



更多数据类型的用法请前往官网查看更多消息 [https://redis.io/commands](https://redis.io/commands) 
