'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/posts/tools/hugo/vc/','title':"Hugo 版本控制",'content':"github page 以 username.github.io 这个项目的master 作为静态资源发布，所以不能把hugo项目放在master，必须开启一个新的分支存储 hugo 项目。\n我这里以 blogedit 分支举例：\ngit branch -a * blogedit master remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/blogedit remotes/origin/master hugo -D 命令会把编译后的静态文件放到 public， 只要确保public 文件夹是 username.githu.io 的master分支即可。\n切换到blogedit分支，然后使用 submodule 创建一个子模块：\n一、初始化 git submodule add git@github.com:fencex/fencex.github.io.git public/ git submodule 会创建 .gitmodules 文件，这个文件可以提交到 blogedit 分支；\ngit submodule 会把 public 放到暂存区，也就是多执行了一步 git add public， 但其实在 blogedit 分支，并不需要这个文件夹；\n所以需要从暂存区剔除:\ngit restore --staged public 二、保存草稿和发布 1、保存草稿指的是保存 hugo 项目的 content\ngit add . git commit -m \u0026#39;update msg\u0026#39; git push origin blogedit 2、发布，则需要到 public 里面操作\nhugo -D cd public git add . git commit -m \u0026#39;update msg\u0026#39; git push origin master "});index.add({'id':1,'href':'/posts/tools/hugo/hugo/','title':"Hugo 基本技巧",'content':"以 book theme 示例\nHugo 添加自定义 css 和 javascript public 目录是最终目录，\nHugo 会把根目录 /static 文件拷贝到 public 下。首先把 js css 拷贝到static 文件夹。示例\n/public /static ├── audio ├── css │ └── audio.css ├── js │ └── audio.js └── speech.mp3 http://localhost:1313/js/audio.js\nhttp://localhost:1313/css/audio.css\nhttp://localhost:1313/speech.mp3\n编辑 theme/book/layouts/_default/baseof.html\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; ... \u0026lt;link rel=stylesheet href=\u0026#34;/css/audio.css\u0026#34; \u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;script src=\u0026#34;/js/audio.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 为每个特定 post 页面指定 js 和 css 文件 hugo 模版支持变量， 如下即可自定义参数。\n--- title : Hugo 基本技巧 description : Hugo 基本技巧 tags: date: 2020-03-27 js1: \u0026#34;/se/js/audiojs/audio.min.js\u0026#34; js2: \u0026#34;/se/js/audiojs/custom.js\u0026#34; css1: \u0026#34;/se/js/audiojs/custom.css\u0026#34; --- 模版中获取变量方式 如下: .Params.css1\n{{ if \u0026#34;.Params.css1\u0026#34; }} \u0026lt;link rel=stylesheet href=\u0026#34;{{ .Params.css1 }}\u0026#34; \u0026gt; {{ end }} ... {{ if \u0026#34;.Params.js1\u0026#34; }} \u0026lt;script src=\u0026#34;{{ .Params.js1 }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} {{ if \u0026#34;.Params.js2\u0026#34; }} \u0026lt;script src=\u0026#34;{{ .Params.js2 }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} "});index.add({'id':2,'href':'/posts/tools/hugo/hugo-audio/','title':"Hugo 支持audio播放",'content':"hugo如何播放mp3文件 纯文本博客有时枯燥无味，试试让网站闹出点声响。\nHugo 支持 html5 element 节点，所以直接在文章中插入 audio 节点即可:\n\u0026lt;audio src=\u0026quot;/speech.mp3\u0026quot; preload=\u0026quot;none\u0026quot; controls=\u0026quot;controls\u0026quot;/\u0026gt;\n\n audio 自定义样式 http://kolber.github.io/audiojs/\n上篇文章中讲到如何在文章中自定义 js css 文件 《Hugo自定义js css 文件》\n下载文件根据上篇文章添加到博客模版中。\n"});index.add({'id':3,'href':'/posts/tools/hugo/hugo-speech/','title':"Hugo 支持博客朗读",'content':"博客朗读  如果博客篇幅较长，有时候文字难免密密麻麻，看着头晕，那为何不增加一个语音朗读博客的功能呢？ 如果文章里有些病句或者语句不通顺，也可通过重新听语音来判断，并予以纠正。\n说干就干。\n思路  得益于上一篇文章：《hugo如何播放mp3文件》，我们知道了该如何在文章中插入 mp3 播放组件， 那么我们要做的就剩下两步：\n 分析博客内容 文字转语音  第一步：分析博客内容\n直接分析 Markdown 文件，暂时找不到好的解析器，决定在 Hugo 编译了 Html 文件之后，再分析 Html 文件来提取文字。\n一篇博客可能包含代码，所以我计划只在关键位置增加朗读功能。\n首先编辑文章时，在需要朗读的位置插入audio组件，这样我们就知道朗读内容的开始。不断检测下一个节点，把文字追加到待转语音文字变量里，直到再次遇到 audio组件节点或者是 H1和H2这类关键节点。\n第二步：文字转语音\n文字转语音有很多解决方案，我选择了 Google 方案，嗯，没有原因。 直接上代码，基本官网示例就能用了。创建语音音频文件示例\n文件保存到 public文件夹中，同时把 mp3 路径回写到 html 文件中。\n由于 Hugo 是 Go 语言开发的，所以这个小插件也用 Go 语言开发。我们把程序编译成可执行文件并拷贝到 Hugo 博客源目录， 每次执行 Hugo 编译后再次执行该文件，达成目标。\n示例代码 1.分析博客内容  go解析html文件可以使用 github.com/PuerkitoBio/goquery\n... func deal(filePath string, assetsPath string) { f, err := os.OpenFile(filePath, os.O_RDONLY, 0777) doc, err := goquery.NewDocumentFromReader(f) defer f.Close() // 查找 audio 找到语音朗读起点 \tdoc.Find(\u0026#34;audio\u0026#34;).Map(func(i int, selection *goquery.Selection) string { parentType := selection.Parent().Nodes[0].DataAtom isEnd := false textSpeech := \u0026#34;\u0026#34; nextItem := selection.Parent().Next() for !isEnd { item := nextItem.Nodes[0] // 遇到同级则停止 \tif item.DataAtom == parentType { isEnd = true continue } var head1 = [] atom.Atom{ atom.H1, atom.H2, atom.H3, atom.H4, atom.H5, atom.H6, } // 遇到h1～h6则停止 \tif contains(head1, item.DataAtom) { isEnd = true continue } // 遇到audio则停止 \tif nextItem.Find(\u0026#34;audio\u0026#34;).Length() \u0026gt; 0 { isEnd = true continue } textSpeech += \u0026#34;。\u0026#34; + nextItem.Text() nextItem = nextItem.Next() } // 文字转语音 \tspeech.TextToSpeech(textSpeech, assetsPath, true) fileName := md5.Sum([]byte(textSpeech)) filename := hex.EncodeToString(fileName[:]) + \u0026#34;.mp3\u0026#34; // 更新audio节点的src \tselection.SetAttr(\u0026#34;src\u0026#34;, \u0026#34;/audio/\u0026#34;+filename) return \u0026#34;\u0026#34; }) // 更新audio节点的src之后，再重新回写到 html 文件 \tf, err = os.OpenFile(filePath, os.O_RDWR|os.O_TRUNC|os.O_CREATE, 0777) if err != nil { fmt.Println(\u0026#34;read fail\u0026#34;, err) } htmlContent, err := doc.Html() _, err = f.Write([]byte(htmlContent)) defer f.Close() }   2.文字转语音  package speech import ( \u0026#34;context\u0026#34; \u0026#34;crypto/md5\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; texttospeech \u0026#34;cloud.google.com/go/texttospeech/apiv1\u0026#34; texttospeechpb \u0026#34;google.golang.org/genproto/googleapis/cloud/texttospeech/v1\u0026#34; ) func TextToSpeech(text string, assetsPath string, isFemale bool) string { ctx := context.Background() client, err := texttospeech.NewClient(ctx) if err != nil { log.Fatal(err) } var ssmlGender = texttospeechpb.SsmlVoiceGender_MALE if isFemale { ssmlGender = texttospeechpb.SsmlVoiceGender_FEMALE } req := texttospeechpb.SynthesizeSpeechRequest{ Input: \u0026amp;texttospeechpb.SynthesisInput{ InputSource: \u0026amp;texttospeechpb.SynthesisInput_Text{Text: text}, }, Voice: \u0026amp;texttospeechpb.VoiceSelectionParams{ LanguageCode: \u0026#34;zh-CN\u0026#34;, SsmlGender: ssmlGender, }, // Select the type of audio utils you want returned. \tAudioConfig: \u0026amp;texttospeechpb.AudioConfig{ AudioEncoding: texttospeechpb.AudioEncoding_MP3, SpeakingRate: 1.1, Pitch: 1, }, } resp, err := client.SynthesizeSpeech(ctx, \u0026amp;req) if err != nil { log.Fatal(err) } // The resp\u0026#39;s AudioContent is binary.  fileName := md5.Sum([]byte(text)) filename := hex.EncodeToString(fileName[:]) + \u0026#34;.mp3\u0026#34; err = ioutil.WriteFile(assetsPath+\u0026#34;/\u0026#34;+filename, resp.AudioContent, 0644) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\\n\u0026#34;, filename) return filename }   "});index.add({'id':4,'href':'/posts/redis/redis-interview/','title':"Redis 面试题",'content':"1. Redis 持久化机制  Redis支持持久化的内存数据库, 当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。\n实现方式：\n单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。\nRDB是Redis默认的持久化方式：\n按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）\nAOF：\nRedis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。\n2. 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题 1. 缓存雪崩  我们可以简单的理解为：由于原有缓存失效，新缓存未到期间 (例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。 解决办法： 大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。\n2. 缓存穿透  缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。 解决办法; 最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。 另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。 5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？\n对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。 Bitmap： 典型的就是哈希表 缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。\n布隆过滤器（推荐） 就是引入了k(k\u0026gt;1)k(k\u0026gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。 Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。 Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。\n3. 缓存预热  缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决思路： 1、直接写个缓存刷新页面，上线时手工操作下； 2、数据量不大，可以在项目启动的时候自动进行加载； 3、定时刷新缓存；\n4. 缓存更新  除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种： （1）定时去清理过期的缓存； （2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。\n5. 缓存降级  当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 以参考日志级别设置预案： （1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； （2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； （3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； （4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。\n服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。\n3. 热点数据和冷数据是什么 热点数据，缓存才有价值 对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存 对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。 对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。 **数据更新前至少读取两次，**缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。 那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。\n4. Memcache与Redis的区别都有哪些？   存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据 数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储 使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。 redis的速度比memcached快很多 Redis支持数据的备份，即master-slave模式的数据备份。  5. 单线程的redis为什么这么快  纯内存操作 单线程操作，避免了频繁的上下文切换 采用了非阻塞I/O多路复用机制  redis的数据类型，以及每种数据类型的使用场景 回答：一共五种 (一)String 这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。 (二)hash 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。 (三)list 使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。 (四)set 因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 (五)sorted set sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。\n5. Redis 内部结构 dict 本质上是为了解决算法中的查找问题（Searching）是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。 本质上是为了解决算法中的查找问题（Searching） sds sds就等同于char * 它可以存储任意二进制数据，不能像C语言字符串那样以字符’\\0’来标识字符串的结 束，因此它必然有个长度字段。 skiplist （跳跃表） 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现， quicklist ziplist 压缩表 ziplist是一个编码后的列表，是由一系列特殊编码的连续内存块组成的顺序型数据结构， redis的过期策略以及内存淘汰机制 redis采用的是定期删除+惰性删除策略。 为什么不用定时删除策略? 定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略. 定期删除+惰性删除是如何工作的呢? 定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 采用定期删除+惰性删除就没其他问题了么? 不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。 在redis.conf中有一行配置\nmaxmemory-policy volatile-lru 1 该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己) volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据，新写入操作会报错 ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。\nRedis 为什么是单线程的 官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问 1）绝大部分请求是纯粹的内存操作（非常快速）2）采用单线程,避免了不必要的上下文切换和竞争条件 3）非阻塞IO优点： 1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)\n支持丰富数据类型，支持string，list，set，sorted set，hash 3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题  同时有多个子系统去set一个key。这个时候要注意什么呢？ 不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。 (1)如果对这个key操作，不要求顺序： 准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可 (2)如果对这个key操作，要求顺序： 分布式锁+时间戳。 假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。 (3) 利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性 对redis的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis内部已经帮你处理好并发的问题了。\nRedis 集群方案应该怎么做？都有哪些方案？ 1.twemproxy，大概概念是，它类似于一个代理方式， 使用时在本需要连接 redis 的地方改为连接 twemproxy， 它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再返回 twemproxy。 缺点： twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。\n2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点\n3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。\n有没有尝试进行多机redis 的部署？如何保证数据一致的？ 主从复制，读写分离 一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。\n对于大量的请求怎么样处理 redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求； redis是通过IO多路复用（select，epoll, kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求的\nRedis 常见性能问题和解决方案？ (1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件 (2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次 (3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内 (4) 尽量避免在压力很大的主库上增加从库 (5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master \u0026lt;- Slave1 \u0026lt;- Slave2 \u0026lt;- Slave3…\n讲解下Redis线程模型 文件事件处理器包括分别是套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。 I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。 工作原理： 1)I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。 尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字.\n为什么Redis的操作是原子性的，怎么保证原子性的？ 对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。 Redis的操作之所以是原子性的，是因为Redis是单线程的。 Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。 多个命令在并发中也是原子性的吗？ 不一定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua==的方式实现.\nRedis事务 Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。 1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。 2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 3.如果在一个事务中出现运行错误，那么正确的命令会被执行。\n1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。 2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。 3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。 4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。\nRedis实现分布式锁 Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。 将 key 的值设为 value ，当且仅当 key 不存在。 若给定的 key 已经存在，则 SETNX 不做任何动作\n解锁：使用 del key 命令就能释放锁 解决死锁： 1）通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。 2） 使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。\n"});index.add({'id':5,'href':'/posts/cheatsheet/data-structure/golang-module-usage/','title':"Linked List 链表（Golang）",'content':"链表和数组差异 链表类似数组，非常大的不同是，可以方便的在列表中间插入和删除元素。\n相对于数组的优点：\n数组把所有元素都保留在同一块内存中，链表通过存储下一个元素的指针来，把分散在内存中的元素包含在链表内。\n相对于数组的缺点：\n如果想在链表中间选择一个元素就会比较困难， 因为不知道该元素的地址，只能从链表的开头开始查找。\n实现 链表应该具有这些方法\n Append(t) 在链表末尾追加元素t Insert(i, t) 在链表指定位置i插入元素t RemoveAt(i) 删除链表指定位置i的元素 IndexOf(t) 返回元素t所在的位置 IsEmpty() 返回链表是否为空链表 Size() 返回链表长度 String() 返回元素按顺序拼接的字符串 Head() 返回第一个位置的元素  "});index.add({'id':6,'href':'/posts/cheatsheet/golang/golang-module-usage/','title':"Golang Module 备忘",'content':"Golang Module 备忘  终于，在 Go 1.11 版本中，新增了module管理模块功能，用来管理依赖包。 文章包你\n一招鲜，走天下\n开启环境变量 export GO111MODULE=on 操作 初始化 go mod init mytest 添加/删除依赖 自动根据 go 文件中的import 添加或者删除依赖\ngo mod tidy "});index.add({'id':7,'href':'/posts/mysql1/spark-intro/','title':"Mysql 面试题",'content':"Mysql 面试题\n通用模块 索引 事务 锁 命令和内置函数 日志 高性能 其他"});index.add({'id':8,'href':'/posts/redis/redis-intro/','title':"Redis 介绍",'content':"本文从初步了解、面向开发、面向运维这三个方面对Redis进行简单介绍\n初步了解  Redis是开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。 自带主从，Lua脚本支持，LRU过期策略，事务和不同级别的磁盘持久性，\n并通过Redis Sentinel和Redis Cluster自动分区实现高可用。\nRedis 作为 NoSql 不会将数据存储在定义表，行和列的定义明确的数据库模式中，而是直接存储在 数据结构中，非常灵活。 但是也可以是有 Module 实现 sqlite 功能，rediSQL。\n基础设计   Redis 是单进程单线程：好处是  代码更清晰，处理逻辑更简单 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 不存在多进程或者多线程导致的切换而消耗CPU 缺点是：无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善； Redis 6.0 使用了多线程使得性能得到2倍提升   Redis 数据存储在内存，数据量不能大于硬件内存 多路 I/O 复用模型:  这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。 采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）   Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，  fork 一个线程后台 重启的时候可以再次加载进行使用   Redis支持数据的备份，配置主从即可  优缺点   性能极高 – Redis 能读的速度是 110000 次 / s,写的速度是 81000 次 / s 原子操作，多个操作支持事务 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上 无法发挥多核CPU的性能，开多个实例  面向开发 数据类型 支持多种数据类型，详见文章Redis数据类型和应用场景\n数据过期 事务 单个操作是原子的，为了使多个任务成为原子操作，需要使用事务 详见文章 Redis事务\n管道技术  Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：\n客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。\n服务端处理命令，并将结果返回给客户端。\n详见文章 Redis管道技术\n面向运维 安全 分布式 主从 持久化、备份和恢复 性能测试"});index.add({'id':9,'href':'/posts/mysql/1-mysql-intro/','title':"零、Mysql 面试题",'content':"Mysql 面试题\n通用模块 索引 事务 锁 命令和内置函数 日志 高性能 其他"});index.add({'id':10,'href':'/posts/notes/golang/go-imagemagick/','title':"Go+ImageMagick使用svg+png绘制复杂图片",'content':"需求  开发过程会有使用go绘制较为复杂图形的需求，比如这次，需要做一个类似拖拽图案验证码。 具体需求：\n 4条边,凹凸平3个形状，随机组合， 随机位置上截图如上形状的图片，并且在原图有如上形状的阴影遮罩  go自带image/draw package 不能绘制复杂的图形（或者说太复杂），经过尝试，可以使用go来绘制svg，再使用imagemagick来进行特效处理，最后再次使用go把图层融合在一起。\n涉及package github.com/ajstarks/svgo #基本图形svg绘制\ngithub.com/gographics/imagick #特效处理（需安装imagemagick)\n先上最终最终效果 步骤 一、go 绘制基本图形 使用 svgo 来绘制 path，生成 svg，代码贴在最后\n二、imagemagick convert把 svg 转化为 png, 加阴影 注：只展示 imagemagick convert，没有融合到 go 程序里\n# ImageMagick convert 命令 convert \\  \\( -background none MSVG:tile-cut.svg -background black -shadow 50x2+0+10 \\  -gravity North -background none -extent 200x200 \\  -compose over \\  \\( -background none MSVG:tile-cut.svg -background white -shadow 120x6+0+0 -resize 95% \\  -gravity center -background none -extent 200x200 \\  \\) \\  -background none -gravity NorthEast -geometry +0+0 -composite \\  \\) \\  -compose over tile-line.svg -gravity center -geometry +0+0 -composite \\ tile.png 代码注释：\n MSVG 支持svg 作为输入源，需要 imagemagick 支持 rsvg， 比如mac： brew install imagemagick --with-librsvg  -background black -shadow 50x2+0+10 前两个数字自己调着看，影响shadow的大小和透明度，后两个是x，y轴偏移，可+可- -background none 背景透明 compose 两个图层组合方式， over 表示 后者在前者之上，还有其他选项，详见官网手册 -gravity North -background none -extent 200x200 -extent 扩展图片尺寸，-gravity North 表示扩展的时候，原图处于什么位置，North 表示北，还有NorthEast 等，详见官网手册  三、处理阴影svg # ImageMagick convert 命令 convert -density 2400 -background transparent MSVG:tile-shadow.svg \\ -fill \u0026#34;rgba(0,0,0,0.3)\u0026#34; -opaque black -resize 200x200 tile-shadow.png 代码注释：\n -opaque 删除图片中颜色，这里删除黑色，填充rgba(0,0,0,0.3), 否则不能转化透明度，这里用了一个trick -density 2400 这里通过修改了分辨率来提高 svg 转化到 png 的细致程度，再强制 -resize 200x200  完成这个小需求绕挺多弯路现总结如下：\n go 可以完成一些简单图形的绘制，比如shape/tile 中At方法其实是对每个点进行上色，这是 draw 包的实现 go 支持图层叠加，支持图层融合 绘制几何图形使用 svg path，很方便，go可以使用 svgo 包，但是不支持转化成png图片，也不能作为draw包的输入源 图片处理 使用 imagemagick, 我这里没有使用扩展把逻辑写到代码里，因为我可以把这些 tile png先生成，go直接叠加图层，降低运算，比如这次需求，4条边，3种形状(凹凸平),2个类型(外边阴影，阴影填充) ，3x3x3x3x2 = 162  附go代码： main.go  main.go\npackage main import ( \u0026#34;image\u0026#34; \u0026#34;log\u0026#34; _ \u0026#34;image/jpeg\u0026#34; _ \u0026#34;image/png\u0026#34; \u0026#34;os\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; \u0026#34;math\u0026#34; \u0026#34;image/png\u0026#34; \u0026#34;image/draw\u0026#34; \u0026#34;captcha/shape\u0026#34; ) func main() { //保存svgs，  saveSvgs() cutWidth := 200 top, right, bottom, left := 1, 1, 0, -1 reader, err := os.Open(\u0026#34;images/14d4c647b216975cb298481f4e550ebc.jpg\u0026#34;) if err != nil { log.Fatal(err) } defer reader.Close() m, _, err := image.Decode(reader) rgbImg := m.(*image.YCbCr) reader2, err := os.Open(\u0026#34;tile.png\u0026#34;) if err != nil { log.Fatal(err) } defer reader2.Close() m2, _, err := image.Decode(reader2) rgbImg2 := m2.(*image.NRGBA64) reader3, err := os.Open(\u0026#34;tile-shadow.png\u0026#34;) if err != nil { log.Fatal(err) } defer reader3.Close() m3, _, err := image.Decode(reader3) rgbImg3 := m3.(*image.NRGBA64) randRect := getRandomRectangle(m.Bounds(), cutWidth, cutWidth) tile := shape.Tile{image.Pt(45, 0), cutWidth, top, right, bottom, left, false} // go draw 包处理代码，  // 新建图片 \toriginImage := image.NewRGBA(rgbImg.Bounds()) // 使用draw原图 \tdraw.Draw(originImage, rgbImg.Bounds(), rgbImg, rgbImg.Bounds().Min, draw.Src) // 把imagemagick处理好的阴影png 绘制到图片的随机位置 randRect 之上 \tdraw.Draw(originImage, randRect.Bounds(), rgbImg3, rgbImg3.Bounds().Min, draw.Over) f2, _ := os.Create(\u0026#34;origin.png\u0026#34;) defer f2.Close() png.Encode(f2, originImage) cutImage4 := image.NewRGBA(image.Rect(0, 0, cutWidth, cutWidth)) // 在随机位置randRect 截取 tile 形状的截图  draw.DrawMask(cutImage4, cutImage4.Bounds(), rgbImg, randRect.Bounds().Min, \u0026amp;tile, tile.Bounds().Min, draw.Src) // 在图片之上添加 imagemagick 处理好的 tile.png \tdraw.Draw(cutImage4, cutImage4.Bounds(), rgbImg2, rgbImg2.Bounds().Min, draw.Over) f5, _ := os.Create(\u0026#34;tile-final.png\u0026#34;) defer f5.Close() png.Encode(f5, cutImage4) } // 绘制svg func saveSvgs(){ cutWidth := 200 top, right, bottom, left := 1, 1, 0, -1 //保存 svg 文件 \ttileSvg := shape.TileSvg{cutWidth, top, right, bottom, left} tileSvg.SaveSvg(\u0026#34;tile-cut.svg\u0026#34;, \u0026#34;stroke-width:10;stroke:White;fill:none;\u0026#34;) tileSvg.SaveSvg(\u0026#34;tile-line.svg\u0026#34;, \u0026#34;stroke-width:2;stroke:White;fill:none;\u0026#34;) tileSvg.SaveSvg(\u0026#34;tile-shadow.svg\u0026#34;, \u0026#34;stroke-width:2;stroke:White;fill:black;fill-opacity:0.5\u0026#34;) } // 随机获取截图位置 func getRandomRectangle(rectangle image.Rectangle, subWidth int, subHeight int) (*image.Rectangle) { bounds := rectangle.Bounds() width := bounds.Max.X - bounds.Min.X height := bounds.Max.Y - bounds.Min.Y rand.Seed(time.Now().Unix()) maxPosX := math.Ceil(float64(width)*0.7) - math.Ceil(float64(subWidth)*1.3) maxPosY := math.Ceil(float64(height)*0.7) - math.Ceil(float64(subHeight)*1.3) if maxPosX \u0026lt; 0 || maxPosY \u0026lt; 0 { //todo error \ttmp := image.Rect(0, 0, 0, 0) return \u0026amp;tmp } posX := rand.Intn(int(maxPosX)) + int(math.Ceil(float64(width)*0.3)) posY := rand.Intn(int(maxPosY)) + int(math.Ceil(float64(height)*0.3)) log.Println(maxPosX, maxPosY) log.Println(posX, posY, posX+int(subWidth), posY+int(subHeight)) retRectangle := image.Rect(posX, posY, posX+int(subWidth), posY+int(subHeight), ) return \u0026amp;retRectangle }   shape/tilesvg.go  绘制svg图形\npackage shape import ( \u0026#34;os\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/ajstarks/svgo\u0026#34; ) type TileSvg struct { Width int T int R int B int L int } /** shape svg path */ func (t *TileSvg) SaveSvg(filename string, stroke string) { width := t.Width height := t.Width f5, _ := os.Create(filename) canvas := svg.New(f5) canvas.Start(width, height) if len(stroke) \u0026lt;= 0 { stroke = \u0026#34;stroke-width:10;stroke:green;fill:red;\u0026#34; } path := fmt.Sprintf(\u0026#34;M%d,%d h%d \u0026#34;, width/5, width/5, width/5) if t.T \u0026gt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 0,1 %d,%d \u0026#34;, width/10, width/10, width*3/5, width/5) } else if t.T \u0026lt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 1,0 %d,%d \u0026#34;, width/10, width/10, width*3/5, width/5) } else { path += fmt.Sprintf(\u0026#34;h+%d \u0026#34;, width/5) } path += fmt.Sprintf(\u0026#34;h%d v%d \u0026#34;, width/5, width/5) if t.R \u0026gt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 0,1 %d,%d \u0026#34;, width/10, width/10, width*4/5, width*3/5) } else if t.R \u0026lt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 1,0 %d,%d \u0026#34;, width/10, width/10, width*4/5, width*3/5) } else { path += fmt.Sprintf(\u0026#34;v+%d \u0026#34;, width/5) } path += fmt.Sprintf(\u0026#34;v%d h-%d \u0026#34;, width/5, width/5) if t.B \u0026gt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 0,1 %d,%d \u0026#34;, width/10, width/10, width*2/5, width*4/5) } else if t.B \u0026lt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 1,0 %d,%d \u0026#34;, width/10, width/10, width*2/5, width*4/5) } else { path += fmt.Sprintf(\u0026#34;h-%d \u0026#34;, width/5) } path += fmt.Sprintf(\u0026#34;h-%d v-%d \u0026#34;, width/5, width/5) if t.L \u0026gt; 0 { path += fmt.Sprintf(\u0026#34; A%d,%d 0 0,1 %d,%d \u0026#34;, width/10, width/10, width/5, width*2/5) } else if t.L \u0026lt; 0 { path += fmt.Sprintf(\u0026#34; A%d,%d 0 1,0 %d,%d \u0026#34;, width/10, width/10, width/5, width*2/5) } else { path += fmt.Sprintf(\u0026#34;v-%d \u0026#34;, width/5) } path += fmt.Sprintf(\u0026#34;v-%d \u0026#34;, width/5) canvas.Path(path, stroke) canvas.End() }   shape/tile.go  shape/tile.go\npackage shape import ( \u0026#34;image\u0026#34; \u0026#34;image/color\u0026#34; ) type Tile struct { Min image.Point Width int T int R int B int L int Revert bool } func (c *Tile) ColorModel() color.Model { return color.AlphaModel } func (c *Tile) Bounds() image.Rectangle { return image.Rect(c.Min.X, c.Min.Y, c.Min.X+c.Width, c.Min.Y+c.Width) } func (c *Tile) At(x, y int) color.Color { colorAt := color.Alpha{220} colorWithin := color.Alpha{220} colorWithout := color.Alpha{0} if c.Revert { colorWithin = color.Alpha{0} colorWithout = color.Alpha{220} } margin := c.Width / 5 if x \u0026gt; (c.Min.X+c.Width/5) \u0026amp;\u0026amp; x \u0026lt; (c.Bounds().Max.X-c.Width/5) \u0026amp;\u0026amp; y \u0026gt; (c.Min.Y+c.Width/5) \u0026amp;\u0026amp; y \u0026lt; (c.Bounds().Max.Y-c.Width/5) { colorAt = colorWithin } else { colorAt = colorWithout } r := c.Width / 10 //todo 优化算法  if c.T != 0 { roundSpot := image.Pt((c.Bounds().Max.X-c.Min.X)/2+c.Min.X, c.Min.Y+margin) xx, yy, rr := float64(x-roundSpot.X)+0.5, float64(y-roundSpot.Y)+0.5, float64(r)+0.5 if xx*xx+yy*yy \u0026lt; rr*rr { if c.T \u0026gt; 0 { colorAt = colorWithin } else { colorAt = colorWithout } } } if c.R != 0 { roundSpot := image.Pt(c.Bounds().Max.X-margin, (c.Bounds().Max.Y-c.Min.Y)/2+c.Min.Y) xx, yy, rr := float64(x-roundSpot.X)+0.5, float64(y-roundSpot.Y)+0.5, float64(r)+0.5 if xx*xx+yy*yy \u0026lt; rr*rr { if c.R \u0026gt; 0 { colorAt = colorWithin } else { colorAt = colorWithout } } } if c.B != 0 { roundSpot := image.Pt((c.Bounds().Max.X-c.Min.X)/2+c.Min.X, (c.Bounds().Max.Y - margin)) xx, yy, rr := float64(x-roundSpot.X)+0.5, float64(y-roundSpot.Y)+0.5, float64(r)+0.5 if xx*xx+yy*yy \u0026lt; rr*rr { if c.B \u0026gt; 0 { colorAt = colorWithin } else { colorAt = colorWithout } } } if c.L != 0 { roundSpot := image.Pt(c.Min.X+margin, (c.Bounds().Max.Y-c.Min.Y)/2+c.Min.Y) xx, yy, rr := float64(x-roundSpot.X)+0.5, float64(y-roundSpot.Y)+0.5, float64(r)+0.5 if xx*xx+yy*yy \u0026lt; rr*rr { if c.L \u0026gt; 0 { colorAt = colorWithin } else { colorAt = colorWithout } } } return colorAt }   "});index.add({'id':11,'href':'/posts/solution/golang/go-imagemagick/','title':"Go+ImageMagick使用svg+png绘制复杂图片",'content':"需求  开发过程会有使用go绘制较为复杂图形的需求，比如这次，需要做一个类似拖拽图案验证码。 具体需求：\n 4条边,凹凸平3个形状，随机组合， 随机位置上截图如上形状的图片，并且在原图有如上形状的阴影遮罩  go自带image/draw package 不能绘制复杂的图形（或者说太复杂），经过尝试，可以使用go来绘制svg，再使用imagemagick来进行特效处理，最后再次使用go把图层融合在一起。\n涉及package github.com/ajstarks/svgo #基本图形svg绘制\ngithub.com/gographics/imagick #特效处理（需安装imagemagick)\n先上最终最终效果 步骤 一、go 绘制基本图形 使用 svgo 来绘制 path，生成 svg，代码贴在最后\n二、imagemagick convert把 svg 转化为 png, 加阴影 注：只展示 imagemagick convert，没有融合到 go 程序里\n# ImageMagick convert 命令 convert \\  \\( -background none MSVG:tile-cut.svg -background black -shadow 50x2+0+10 \\  -gravity North -background none -extent 200x200 \\  -compose over \\  \\( -background none MSVG:tile-cut.svg -background white -shadow 120x6+0+0 -resize 95% \\  -gravity center -background none -extent 200x200 \\  \\) \\  -background none -gravity NorthEast -geometry +0+0 -composite \\  \\) \\  -compose over tile-line.svg -gravity center -geometry +0+0 -composite \\ tile.png 代码注释：\n MSVG 支持svg 作为输入源，需要 imagemagick 支持 rsvg， 比如mac： brew install imagemagick --with-librsvg  -background black -shadow 50x2+0+10 前两个数字自己调着看，影响shadow的大小和透明度，后两个是x，y轴偏移，可+可- -background none 背景透明 compose 两个图层组合方式， over 表示 后者在前者之上，还有其他选项，详见官网手册 -gravity North -background none -extent 200x200 -extent 扩展图片尺寸，-gravity North 表示扩展的时候，原图处于什么位置，North 表示北，还有NorthEast 等，详见官网手册  三、处理阴影svg # ImageMagick convert 命令 convert -density 2400 -background transparent MSVG:tile-shadow.svg \\ -fill \u0026#34;rgba(0,0,0,0.3)\u0026#34; -opaque black -resize 200x200 tile-shadow.png 代码注释：\n -opaque 删除图片中颜色，这里删除黑色，填充rgba(0,0,0,0.3), 否则不能转化透明度，这里用了一个trick -density 2400 这里通过修改了分辨率来提高 svg 转化到 png 的细致程度，再强制 -resize 200x200  完成这个小需求绕挺多弯路现总结如下：\n go 可以完成一些简单图形的绘制，比如shape/tile 中At方法其实是对每个点进行上色，这是 draw 包的实现 go 支持图层叠加，支持图层融合 绘制几何图形使用 svg path，很方便，go可以使用 svgo 包，但是不支持转化成png图片，也不能作为draw包的输入源 图片处理 使用 imagemagick, 我这里没有使用扩展把逻辑写到代码里，因为我可以把这些 tile png先生成，go直接叠加图层，降低运算，比如这次需求，4条边，3种形状(凹凸平),2个类型(外边阴影，阴影填充) ，3x3x3x3x2 = 162  附go代码： main.go  main.go\npackage main import ( \u0026#34;image\u0026#34; \u0026#34;log\u0026#34; _ \u0026#34;image/jpeg\u0026#34; _ \u0026#34;image/png\u0026#34; \u0026#34;os\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; \u0026#34;math\u0026#34; \u0026#34;image/png\u0026#34; \u0026#34;image/draw\u0026#34; \u0026#34;captcha/shape\u0026#34; ) func main() { //保存svgs，  saveSvgs() cutWidth := 200 top, right, bottom, left := 1, 1, 0, -1 reader, err := os.Open(\u0026#34;images/14d4c647b216975cb298481f4e550ebc.jpg\u0026#34;) if err != nil { log.Fatal(err) } defer reader.Close() m, _, err := image.Decode(reader) rgbImg := m.(*image.YCbCr) reader2, err := os.Open(\u0026#34;tile.png\u0026#34;) if err != nil { log.Fatal(err) } defer reader2.Close() m2, _, err := image.Decode(reader2) rgbImg2 := m2.(*image.NRGBA64) reader3, err := os.Open(\u0026#34;tile-shadow.png\u0026#34;) if err != nil { log.Fatal(err) } defer reader3.Close() m3, _, err := image.Decode(reader3) rgbImg3 := m3.(*image.NRGBA64) randRect := getRandomRectangle(m.Bounds(), cutWidth, cutWidth) tile := shape.Tile{image.Pt(45, 0), cutWidth, top, right, bottom, left, false} // go draw 包处理代码，  // 新建图片 \toriginImage := image.NewRGBA(rgbImg.Bounds()) // 使用draw原图 \tdraw.Draw(originImage, rgbImg.Bounds(), rgbImg, rgbImg.Bounds().Min, draw.Src) // 把imagemagick处理好的阴影png 绘制到图片的随机位置 randRect 之上 \tdraw.Draw(originImage, randRect.Bounds(), rgbImg3, rgbImg3.Bounds().Min, draw.Over) f2, _ := os.Create(\u0026#34;origin.png\u0026#34;) defer f2.Close() png.Encode(f2, originImage) cutImage4 := image.NewRGBA(image.Rect(0, 0, cutWidth, cutWidth)) // 在随机位置randRect 截取 tile 形状的截图  draw.DrawMask(cutImage4, cutImage4.Bounds(), rgbImg, randRect.Bounds().Min, \u0026amp;tile, tile.Bounds().Min, draw.Src) // 在图片之上添加 imagemagick 处理好的 tile.png \tdraw.Draw(cutImage4, cutImage4.Bounds(), rgbImg2, rgbImg2.Bounds().Min, draw.Over) f5, _ := os.Create(\u0026#34;tile-final.png\u0026#34;) defer f5.Close() png.Encode(f5, cutImage4) } // 绘制svg func saveSvgs(){ cutWidth := 200 top, right, bottom, left := 1, 1, 0, -1 //保存 svg 文件 \ttileSvg := shape.TileSvg{cutWidth, top, right, bottom, left} tileSvg.SaveSvg(\u0026#34;tile-cut.svg\u0026#34;, \u0026#34;stroke-width:10;stroke:White;fill:none;\u0026#34;) tileSvg.SaveSvg(\u0026#34;tile-line.svg\u0026#34;, \u0026#34;stroke-width:2;stroke:White;fill:none;\u0026#34;) tileSvg.SaveSvg(\u0026#34;tile-shadow.svg\u0026#34;, \u0026#34;stroke-width:2;stroke:White;fill:black;fill-opacity:0.5\u0026#34;) } // 随机获取截图位置 func getRandomRectangle(rectangle image.Rectangle, subWidth int, subHeight int) (*image.Rectangle) { bounds := rectangle.Bounds() width := bounds.Max.X - bounds.Min.X height := bounds.Max.Y - bounds.Min.Y rand.Seed(time.Now().Unix()) maxPosX := math.Ceil(float64(width)*0.7) - math.Ceil(float64(subWidth)*1.3) maxPosY := math.Ceil(float64(height)*0.7) - math.Ceil(float64(subHeight)*1.3) if maxPosX \u0026lt; 0 || maxPosY \u0026lt; 0 { //todo error \ttmp := image.Rect(0, 0, 0, 0) return \u0026amp;tmp } posX := rand.Intn(int(maxPosX)) + int(math.Ceil(float64(width)*0.3)) posY := rand.Intn(int(maxPosY)) + int(math.Ceil(float64(height)*0.3)) log.Println(maxPosX, maxPosY) log.Println(posX, posY, posX+int(subWidth), posY+int(subHeight)) retRectangle := image.Rect(posX, posY, posX+int(subWidth), posY+int(subHeight), ) return \u0026amp;retRectangle }   shape/tilesvg.go  绘制svg图形\npackage shape import ( \u0026#34;os\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/ajstarks/svgo\u0026#34; ) type TileSvg struct { Width int T int R int B int L int } /** shape svg path */ func (t *TileSvg) SaveSvg(filename string, stroke string) { width := t.Width height := t.Width f5, _ := os.Create(filename) canvas := svg.New(f5) canvas.Start(width, height) if len(stroke) \u0026lt;= 0 { stroke = \u0026#34;stroke-width:10;stroke:green;fill:red;\u0026#34; } path := fmt.Sprintf(\u0026#34;M%d,%d h%d \u0026#34;, width/5, width/5, width/5) if t.T \u0026gt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 0,1 %d,%d \u0026#34;, width/10, width/10, width*3/5, width/5) } else if t.T \u0026lt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 1,0 %d,%d \u0026#34;, width/10, width/10, width*3/5, width/5) } else { path += fmt.Sprintf(\u0026#34;h+%d \u0026#34;, width/5) } path += fmt.Sprintf(\u0026#34;h%d v%d \u0026#34;, width/5, width/5) if t.R \u0026gt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 0,1 %d,%d \u0026#34;, width/10, width/10, width*4/5, width*3/5) } else if t.R \u0026lt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 1,0 %d,%d \u0026#34;, width/10, width/10, width*4/5, width*3/5) } else { path += fmt.Sprintf(\u0026#34;v+%d \u0026#34;, width/5) } path += fmt.Sprintf(\u0026#34;v%d h-%d \u0026#34;, width/5, width/5) if t.B \u0026gt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 0,1 %d,%d \u0026#34;, width/10, width/10, width*2/5, width*4/5) } else if t.B \u0026lt; 0 { path += fmt.Sprintf(\u0026#34;A%d,%d 0 1,0 %d,%d \u0026#34;, width/10, width/10, width*2/5, width*4/5) } else { path += fmt.Sprintf(\u0026#34;h-%d \u0026#34;, width/5) } path += fmt.Sprintf(\u0026#34;h-%d v-%d \u0026#34;, width/5, width/5) if t.L \u0026gt; 0 { path += fmt.Sprintf(\u0026#34; A%d,%d 0 0,1 %d,%d \u0026#34;, width/10, width/10, width/5, width*2/5) } else if t.L \u0026lt; 0 { path += fmt.Sprintf(\u0026#34; A%d,%d 0 1,0 %d,%d \u0026#34;, width/10, width/10, width/5, width*2/5) } else { path += fmt.Sprintf(\u0026#34;v-%d \u0026#34;, width/5) } path += fmt.Sprintf(\u0026#34;v-%d \u0026#34;, width/5) canvas.Path(path, stroke) canvas.End() }   shape/tile.go  shape/tile.go\npackage shape import ( \u0026#34;image\u0026#34; \u0026#34;image/color\u0026#34; ) type Tile struct { Min image.Point Width int T int R int B int L int Revert bool } func (c *Tile) ColorModel() color.Model { return color.AlphaModel } func (c *Tile) Bounds() image.Rectangle { return image.Rect(c.Min.X, c.Min.Y, c.Min.X+c.Width, c.Min.Y+c.Width) } func (c *Tile) At(x, y int) color.Color { colorAt := color.Alpha{220} colorWithin := color.Alpha{220} colorWithout := color.Alpha{0} if c.Revert { colorWithin = color.Alpha{0} colorWithout = color.Alpha{220} } margin := c.Width / 5 if x \u0026gt; (c.Min.X+c.Width/5) \u0026amp;\u0026amp; x \u0026lt; (c.Bounds().Max.X-c.Width/5) \u0026amp;\u0026amp; y \u0026gt; (c.Min.Y+c.Width/5) \u0026amp;\u0026amp; y \u0026lt; (c.Bounds().Max.Y-c.Width/5) { colorAt = colorWithin } else { colorAt = colorWithout } r := c.Width / 10 //todo 优化算法  if c.T != 0 { roundSpot := image.Pt((c.Bounds().Max.X-c.Min.X)/2+c.Min.X, c.Min.Y+margin) xx, yy, rr := float64(x-roundSpot.X)+0.5, float64(y-roundSpot.Y)+0.5, float64(r)+0.5 if xx*xx+yy*yy \u0026lt; rr*rr { if c.T \u0026gt; 0 { colorAt = colorWithin } else { colorAt = colorWithout } } } if c.R != 0 { roundSpot := image.Pt(c.Bounds().Max.X-margin, (c.Bounds().Max.Y-c.Min.Y)/2+c.Min.Y) xx, yy, rr := float64(x-roundSpot.X)+0.5, float64(y-roundSpot.Y)+0.5, float64(r)+0.5 if xx*xx+yy*yy \u0026lt; rr*rr { if c.R \u0026gt; 0 { colorAt = colorWithin } else { colorAt = colorWithout } } } if c.B != 0 { roundSpot := image.Pt((c.Bounds().Max.X-c.Min.X)/2+c.Min.X, (c.Bounds().Max.Y - margin)) xx, yy, rr := float64(x-roundSpot.X)+0.5, float64(y-roundSpot.Y)+0.5, float64(r)+0.5 if xx*xx+yy*yy \u0026lt; rr*rr { if c.B \u0026gt; 0 { colorAt = colorWithin } else { colorAt = colorWithout } } } if c.L != 0 { roundSpot := image.Pt(c.Min.X+margin, (c.Bounds().Max.Y-c.Min.Y)/2+c.Min.Y) xx, yy, rr := float64(x-roundSpot.X)+0.5, float64(y-roundSpot.Y)+0.5, float64(r)+0.5 if xx*xx+yy*yy \u0026lt; rr*rr { if c.L \u0026gt; 0 { colorAt = colorWithin } else { colorAt = colorWithout } } } return colorAt }   "});index.add({'id':12,'href':'/posts/cheatsheet/scala/go-imagemagick/','title':"Scala 简介",'content':"特点关键词：  jvm、 静态类型、 多范例  面向对象-trait(mixin组合) 函数式编程FP-适用大数据和并发  Immutable 值、 First Class 函数、 无副作用函数 高阶函数 函数集合     泛型\n通过类型推断，Scala代码通常与动态类型语言中的代码一样简洁。 可扩展架构  trait: mixin组合 抽象成员和泛型 嵌套类 明确的自我类型??    其他关键词 REPL\n“读取-求值-输出”循环(英语:Read-Eval-Print Loop)，sbt 终端启动 console。\n$ sbt sbt:fence\u0026gt; console scala\u0026gt; 语法 class Upper { def upper(strings: String*): Seq[String] = { strings.map((s:String) =\u0026gt; s.toUpperCase()) } } val up = new Upper println(up.upper(\u0026#34;Hello\u0026#34;, \u0026#34;World!\u0026#34;)) 方法定义 def upper(strings: String*): Seq[String] = ...  def strings: String* 可变函数，类型为 WrappedArray, : 后面返回值，类型为 scala.collection.mutable.ArrayBuffer 泛型参数化类型使用 [\u0026hellip;]， Java 使用的是 \u0026lt;\u0026hellip;\u0026gt;， 因为 scala 支持 \u0026lt; 这个符号出现在 变量名 中。 = 不可缺少，为了使参略分号之时可以推断出分号，同时是 函数式编程中的原则 map 参数为 匿名函数\n(s:String) =\u0026gt; s.toUpperCase()， 方法中可以使用 return， 但是 匿名函数不能使用 return  方法 vs 函数 METHODS VERSUS FUNCTIONS\n method 方法是类或者对象中的 function 函数 调用 method 方法时，隐式将this作为附加参数 (s:String) =\u0026gt; s.toUpperCase() 是一个函数，而不是方法  "});index.add({'id':13,'href':'/docs/example/','title':"Example Site",'content':"Introduction Ferre hinnitibus erat accipitrem dixi Troiae tollens Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\n Pedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret  Est simul fameque tauri qua ad Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo;  Trepident sitimque Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"});index.add({'id':14,'href':'/docs/example/table-of-contents/with-toc/','title':"With ToC",'content':"Caput vino delphine in tamen vias Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  Natus quaerere Pectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\n Phrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\n Limitibus misere sit Aurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua Iuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta Mortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"});index.add({'id':15,'href':'/posts/mysql1/spark-advanced/','title':"Spark 高级",'content':"spark\n"});index.add({'id':16,'href':'/docs/example/table-of-contents/without-toc/','title':"Without ToC",'content':"At me ipso nepotibus nunc celebratior genus Tanto oblite Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius Quibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\n Remansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit  Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae Credulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\n Baculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra  Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"});index.add({'id':17,'href':'/posts/mysql/3-mysql-mac-intro/','title':"一、Mysql Mac 安装和使用",'content':"一、安装 1、执行安装命令\nbrew install mysql 2、安装完后启动mysql\nmysql.server start 3、执行安全设置\nmysql_secure_installation 显示如下\nThere are three levels of password validation policy: LOW Length \u0026gt;= 8 MEDIUM Length \u0026gt;= 8, numeric, mixed case, and special characters STRONG Length \u0026gt;= 8, numeric, mixed case, special characters and dictionary file 按照提示选择密码等级，并设置root密码\n二、创建新的数据库、用户并授权 1、登录mysql\nmysql -u root -p 按提示输入root密码\nroot@poksi-test-2019:~# mysql -u root -p Enter password: 2、创建数据库\ncreate database testdb character set utf8mb4; 3、创建用户\ncreate user \u0026#39;testtest_u\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;testtest_PWD_123\u0026#39;; 4、授权用户\ngrant all privileges on testdb.* to \u0026#39;testtest_u\u0026#39;@\u0026#39;%\u0026#39;; flush privileges; 5、查看当前的数据库\nshow databases; 6、显示当前数据库的表单\nshow tables; 三、建表 CREATE TABLE t_user( key_id VARCHAR(255) NOT NULL PRIMARY KEY, -- id 统一命名为key_id  user_name VARCHAR(255) NOT NULL , password VARCHAR(255) NOT NULL , phone VARCHAR(255) NOT NULL, deleted INT NOT NULL DEFAULT 0, -- 逻辑删除标志默认值  create_time timestamp NULL default CURRENT_TIMESTAMP, -- 创建时间默认值  update_time timestamp NULL default CURRENT_TIMESTAMP -- 修改时间默认值 ) ENGINE=INNODB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8mb4; 四、检查mysql服务状态 先退出mysql命令行，输入命令\nsystemctl status mysql.service 显示如下结果说明mysql服务是正常的\n● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2019-05-22 10:53:13 CST; 13min ago Main PID: 16686 (mysqld) Tasks: 29 (limit: 4667) CGroup: /system.slice/mysql.service └─16686 /usr/sbin/mysqld --daemonize --pid-file=/run/mysqld/mysqld.pid May 22 10:53:12 poksi-test-2019 systemd[1]: Starting MySQL Community Server... May 22 10:53:13 poksi-test-2019 systemd[1]: Started MySQL Community Server. "});index.add({'id':18,'href':'/posts/mysql/3-mysql-sysbench/','title':"二、Mysql 基准测试 mysqlslap 和 sysbench",'content':"mysqlslap 和 sysbench，必须要掌握；\n还有其他的补充。\n http_load sql-bench dbt2 的 TPC-C percona的 TPCC-mySQL测试工具  mysqlslap mysql 自带\n$ mysqlslap -a -c 200 -i 10 -uroot -pekstox mysqlslap: [Warning] Using a password on the command line interface can be insecure. Benchmark Average number of seconds to run all queries: 0.580 seconds Minimum number of seconds to run all queries: 0.467 seconds Maximum number of seconds to run all queries: 0.668 seconds Number of clients running queries: 10 Average number of queries per client: 0 如果出现： mysqlslap: Error when connecting to server: 1040 Too many connections 修改最大连接数 mysql\u0026gt; show variables like \u0026#39;%max_connections%\u0026#39;; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 151 | +-----------------+-------+ 使用语法如下： # mysqlslap [options] 常用参数 [options] 详细说明： --auto-generate-sql, -a 自动生成测试表和数据，表示用mysqlslap工具自己生成的SQL脚本来测试并发压力。 --auto-generate-sql-load-type=type 测试语句的类型。代表要测试的环境是读操作还是写操作还是两者混合的。取值包括：read，key，write，update和mixed(默认)。 --auto-generate-sql-add-auto-increment 代表对生成的表自动添加auto_increment列，从5.1.18版本开始支持。 --number-char-cols=N, -x N 自动生成的测试表中包含多少个字符类型的列，默认1 --number-int-cols=N, -y N 自动生成的测试表中包含多少个数字类型的列，默认1 --number-of-queries=N 总的测试查询次数(并发客户数×每客户查询次数) --query=name,-q 使用自定义脚本执行测试，例如可以调用自定义的一个存储过程或者sql语句来执行测试。 --create-schema 代表自定义的测试库名称，测试的schema，MySQL中schema也就是database。 --commint=N 多少条DML后提交一次。 --compress, -C 如果服务器和客户端支持都压缩，则压缩信息传递。 --concurrency=N, -c N 表示并发量，也就是模拟多少个客户端同时执行select。可指定多个值，以逗号或者--delimiter参数指定的值做为分隔符。例如：--concurrency=100,200,500。 --engine=engine_name, -e engine_name 代表要测试的引擎，可以有多个，用分隔符隔开。例如：--engines=myisam,innodb。 --iterations=N, -i N 测试执行的迭代次数，代表要在不同并发环境下，各自运行测试多少次。 --only-print 只打印测试语句而不实际执行。 --detach=N 执行N条语句后断开重连。 --debug-info, -T 打印内存和CPU的相关信息。 说明： 测试的过程需要生成测试表，插入测试数据，这个mysqlslap可以自动生成，默认生成一个mysqlslap的schema，如果已经存在则先删除。可以用\u0026ndash;only-print来打印实际的测试过程，整个测试完成后不会在数据库中留下痕迹。\n各种测试参数实例（-p后面跟的是mysql的root密码）：\n单线程测试。测试做了什么。 # mysqlslap -a -uroot -p123456 多线程测试。使用–concurrency来模拟并发连接。 # mysqlslap -a -c 100 -uroot -p123456 迭代测试。用于需要多次执行测试得到平均值。 # mysqlslap -a -i 10 -uroot -p123456 # mysqlslap ---auto-generate-sql-add-autoincrement -a -uroot -p123456 # mysqlslap -a --auto-generate-sql-load-type=read -uroot -p123456 # mysqlslap -a --auto-generate-secondary-indexes=3 -uroot -p123456 # mysqlslap -a --auto-generate-sql-write-number=1000 -uroot -p123456 # mysqlslap --create-schema world -q \u0026#34;select count(*) from City\u0026#34; -uroot -p123456 # mysqlslap -a -e innodb -uroot -p123456 # mysqlslap -a --number-of-queries=10 -uroot -p123456 测试同时不同的存储引擎的性能进行对比： # mysqlslap -a --concurrency=50,100 --number-of-queries 1000 --iterations=5 --engine=myisam,innodb --debug-info -uroot -p123456 执行一次测试，分别50和100个并发，执行1000次总查询： # mysqlslap -a --concurrency=50,100 --number-of-queries 1000 --debug-info -uroot -p123456 50和100个并发分别得到一次测试结果(Benchmark)，并发数越多，执行完所有查询的时间越长。为了准确起见，可以多迭代测试几次: # mysqlslap -a --concurrency=50,1 sysbench CPU 测试 $ cat /proc/cpuinfo model name\t: Intel(R) Core(TM) i5-6600 CPU @ 3.30GHz stepping\t: 3 microcode\t: 0xd6 cpu MHz\t: 800.105 cache size\t: 6144 KB $ sysbench --test=cpu --cpu-max-prime=20000 run IO测试 ## 准备 $ sysbench --test=fileio --file-total-size=10G prepare ... 10737418240 bytes written in 67.60 seconds (151.47 MiB/sec). ## IO随机读写 $ sysbench --test=fileio --file-total-size=10G --file-test-mode=rndrw \\ --init-rng=on --max-time=300 --max-requests=0 run File operations: reads/s: 199.39 writes/s: 132.93 fsyncs/s: 425.29 Throughput: read, MiB/s: 3.12 written, MiB/s: 2.08 General statistics: total time: 300.0050s total number of events: 227291 Latency (ms): min: 0.00 avg: 1.32 max: 162.07 95th percentile: 9.06 sum: 299670.12 Threads fairness: events (avg/stddev): 227291.0000/0.00 execution time (avg/stddev): 299.6701/0.00 mode: seqwr 顺序写入 seqrewr 顺序重写 seqrd 顺序读取 rndrd 随机读取 rndwr 随机写入 rdnrw 混合随机读/写 ## 删除测试文件 $ sysbench --test=fileio --file-total-size=10G cleanup OLTP 测试 还是三步走 prepare -\u0026gt; run -\u0026gt; cleanup\nOLTP 基准测试模拟事务处理系统\n## 准备数据 $ sysbench oltp_insert --table-size=100000 --mysql-db=test \\ --mysql-user=root --mysql-password=ekstox --time=50 \\ --max-requests=0 --threads=1 --db-driver=mysql prepare $ sysbench oltp_insert --table-size=100000 --mysql-db=test \\ --mysql-user=root --mysql-password=ekstox --time=50 \\ --max-requests=0 --threads=1 --db-driver=mysql run oltp 模式支持： oltp_delete oltp_insert oltp_point_select oltp_read_only oltp_read_write oltp_update_index oltp_update_non_index oltp_write_only select_random_points select_random_ranges $ sysbench oltp_insert --table-size=100000 --mysql-db=test \\ --mysql-user=root --mysql-password=ekstox --time=50 \\ --max-requests=0 --threads=1 --db-driver=mysql cleanup "});index.add({'id':19,'href':'/posts/csp/redis-data-types/','title':"WEB 安全 - 内容安全策略介绍与使用",'content':"内容安全策略 (CSP, Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。 这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途。\n一、简介 CSP被设计成向后兼容；不支持的浏览器依然可以运行使用了它的服务器页面，反之亦然。不支持CSP的浏览器会忽略它，像平常一样运行，默认对网页内容使用标准的同源策略。如果网站不提供CSP头部，浏览器同样会使用标准的（同源策略）。\n开启CSP就如配置您的页面服务来返回Content-Security-Policy HTTP 头部一样简单.\n二、目标 CSP的主要目标是减少和报告XSS攻击. XSS攻击利用浏览器对从服务器接受的内容的信任。恶意的脚本在受害的浏览器被执行, 因为浏览器相信内容源，甚至当内容源并不是从它应该来的地方过来的。\n早些年，javascript 刚出来的时候，是非常不安全的，经常爆出漏洞，为了安全，浏览器都有一项配置项，禁止脚本执行，但现在的进入web3.0，todo，禁止脚本执行的结果，可能是网站都不能正常运行。\n仅仅支持 HTTPS 传输数据，代理服务器上控制 HTTP 页面重定向到 HTTPS 页面\n三、用法 3.1 开启安全策略 你可以使用 Content-Security-Policy HTTP头部 来指定策略，像这样:\nContent-Security-Policy: policy policy参数是一个包含了各种描述你的CSP策略指令的字符串。\n3.1.1 常用示例 示例1  所有内容均来自站点的同一个源（不包含子域名） 展开  Content-Security-Policy: default-src \u0026#39;self\u0026#39;     示例2  允许内容来自信任的域名及其子域名 展开  Content-Security-Policy: default-src \u0026#39;self\u0026#39; *.trusted.com     示例3  允许加载任何源的图片， 限制音频/视频来源，限制脚本来源 展开  Content-Security-Policy: default-src \u0026#39;self\u0026#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com  图片可以从任何地方加载(注意 \u0026ldquo;*\u0026rdquo; 通配符)。 多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)。 可运行脚本仅允许来自于userscripts.example.com。     示例4  所有内容都要通过SSL方式获取，以避免攻击者窃听用户发出的请求。 展开  Content-Security-Policy: default-src https://onlinebanking.jumbobank.com 该服务器仅允许通过HTTPS方式并仅从onlinebanking.jumbobank.com域名来访问文档。\n   3.2 策略触发上报 策略触发上报报文示例：\n{ \u0026#34;csp-report\u0026#34;: { \u0026#34;document-uri\u0026#34;: \u0026#34;http://example.com/signup.html\u0026#34;, //发生违规的文档的URI。 \u0026#34;referrer\u0026#34;: \u0026#34;\u0026#34;, //违规发生处的文档引用（地址）。 \u0026#34;blocked-uri\u0026#34;: \u0026#34;http://example.com/css/style.css\u0026#34;, //被CSP阻止的资源URI。如果被阻止的URI来自不同的源而非文档URI，那么被阻止的资源URI会被删减，仅保留协议，主机和端口号。 \u0026#34;violated-directive\u0026#34;: \u0026#34;style-src cdn.example.com\u0026#34;, //违反的策略名称。 \u0026#34;original-policy\u0026#34;: \u0026#34;default-src \u0026#39;none\u0026#39;; style-src cdn.example.com; report-uri /_/csp-reports\u0026#34;, //在 Content-Security-Policy HTTP 头部中指明的原始策略。 \u0026#34;disposition\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;effective-directive\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;script-sample\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;status-code\u0026#34;: \u0026#34;\u0026#34;, } } 四、实践\n参考  官网 https://www.w3.org/TR/CSP 浏览器支持情况 https://caniuse.com/#search=csp  caniuse.com 是一个神奇的网站。：D\n"});index.add({'id':20,'href':'/posts/redis/redis-data-types/','title':"Redis 数据类型与适用场景",'content':"redis 常被拿来与 memcached 来比较，但非常不通的地方就在于 Redis 有非常出色的数据结构，使用非常简便。 本文介绍常用的数据类型和使用场景 Strings Lists Hashes Sets Sorted-Sets 等。\n数据类型 Strings 字符串是Redis值中最基本的一种。 Redis字符串是二进制安全的，这意味着Redis字符串可以包含任何类型的数据，例如JPEG图像或序列化的Ruby对象。\n字符串值的最大长度为512 MB。\n使用场景：\n 使用INCR系列中的命令将字符串用作原子计数器：INCR，DECR，INCRBY。 使用APPEND命令附加到字符串。 使用字符串作为带有GETRANGE和SETRANGE的随机访问向量。 在很小的空间内编码大量数据，或使用GETBIT和SETBIT创建Redis支持的Bloom Filter。 会话缓存：许多网站利用Redis字符串创建会话缓存，以通过缓存HTML片段或页面来加快其网站体验。由于数据是临时存储在RAM中的，因此此属性使Redis成为会话缓存的理想选择。它能够临时存储特定于用户的数据，例如在线商店中购物车中存储的项目，这一点至关重要，因为您的用户在注销或失去连接时不会丢失其数据。PHP的缓存甚至可以直接在配置文件中指定存储到redis。  Lists Redis列表只是字符串列表，按插入顺序排序。可以将元素添加到Redis列表中，从而将新元素推到列表的顶部（左侧）或结尾（右侧）。\n最大支持 2^32 - 1 个元素， 4294967295 40亿\n使用场景：\n 在社交网络中对时间轴建模，请使用LPUSH以便在用户时间轴中添加新元素，并使用LRANGE来检索一些最近插入的项目 可以将LPUSH与LTRIM一起使用，以创建一个列表，该列表从不超过给定数量的元素，而只记住最新的N个元素 列表可以用作消息传递，用作跨系统的数据载体 可以使用列表做更多的事情，此数据类型支持许多命令，包括阻塞命令，例如BLPOP  Sets Redis集是字符串的无序集合。添加，删除和测试成员的存在 O(1) 复杂度。（恒定时间，与Set中包含的元素数量无关）。\nRedis集具有不允许重复成员的理想属性。多次添加同一元素将导致集合具有该元素的单个副本。实际上，这意味着添加成员不需要检查是否存在，然后进行添加操作。\n可以在很短的时间内完成集的相交，交集，差集。\n最大支持 2^32 - 1 个元素， 4294967295 40亿\n使用场景：\n 使用Redis集来跟踪独特的事物， 比如UV，根据IP去重。想知道访问给定博客帖子的所有唯一IP地址吗？每次处理页面视图时，只需使用SADD。您确定不会插入重复的IP。 Redis Set 很好地表示关系。您可以使用Set代表每个标签，使用Redis创建标签系统。然后，可以使用SADD命令将具有给定标签的所有对象的所有ID添加到代表该特定标签的Set中。您是否希望所有对象的所有ID同时具有三个不同的标签？只需使用SINTER。 您可以使用 Set 使用 SPOP 或 SRANDMEMBER 命令随机提取元素。  Hashes Redis Hashes 是字符串字段和字符串值之间的映射，因此它们是表示对象的理想数据类型（例如，具有多个字段（例如名称，姓氏，年龄等）的User）：\n@cli HMSET user:1000 username antirez password P1pp0 age 34 HGETALL user:1000 HSET user:1000 password 12345 HGETALL user:1000  具有几个字段（官方建议大概最多一百个左右）的散列以占用很少空间的方式存储，因此您可以在小型Redis实例中存储数百万个对象。\n尽管哈希主要用于表示对象，但是它们能够存储许多元素，因此您也可以将哈希用于许多其他任务。\n每个哈希最多可以存储2 ^ 32-1个字段-值对（超过40亿个）\n使用场景：\n 缓存用户信息 可以相似的多个 String 用 Hashes 汇集在一起  Sorted sets 与Redis集类似，Redis排序集是非重复的String集合。区别在于，排序集的每个成员都与Score相关联，该得分用于从最小到最大得分中获取排序的排序集。虽然成员是唯一的，但分数可能会重复。\n使用排序集，您可以非常快速地添加 O(log(N))，删除 O(M*log(N)) 或更新元素（时间与元素数量的对数成正比）。\n由于元素是按顺序排序的，因此可以非常快速地按分数或按排名（位置）获得范围。\n访问排序集的中间位置也非常快，因此您可以将排序集用作非重复元素的智能列表，\n从中可以快速访问所需的所有内容：元素的顺序，快速检测元素是否存在，对中间元素的快速访问。\n简而言之，使用Sorted Sets，可以执行许多性能出色的任务，而这些任务实际上很难在其他类型的数据库中建模。\n比如：\n  积分排行版，使用 ZADD 来更新元素的分值， ZRANGE 来获取范围分值的数据，ZRANK 查找排行，时间复杂度都是 O(log(N)+M) ,速度很快\n  Sorted Sets 通常用于索引Redis中存储的数据。例如，如果您有许多代表用户的哈希，则可以使用已排序的集合，其元素具有用户的年龄作为得分，而用户的ID作为值。因此，使用ZRANGEBYSCORE检索具有给定年龄段的所有用户将非常简单快捷。\n  Sorted Set 还可用作为延迟队列，使用 时间戳 作为score， ZRANGEBYSCORE 来查找符合时间范围的数据，并且再消费完成以后，使用 ZREMRANGEBYSCORE 来删除这部分数据\n  Bitmaps Bitmaps and HyperLogLogs 实际上是基于 String 类型，但是他们有自己的语意\nBitmaps 支持如下几个操作：\nBITCOUNT BITFIELD BITOP BITPOS GETBIT and SETBIT\nBitmaps 是某些类型信息的非常节省空间的表示形式。 一个示例是需要用户访问历史的Web应用程序，因此例如可以确定哪些用户是beta功能的良好目标。\n使用场景：\n 制作快速，简便，实时的指标 每日活跃用户，每日一个key，根据用户ID对 redis key 的偏移位进行置1，   HyperLogLogs Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\n类似 set 计算值基数集的数量，但是不能返回具体的元素。\n一边 ADD 一边计算， 所以在使用 PFCOUNT 的时候，只是取一个值，并未进行计算所以复杂度是 O(1)\n当用单个键调用PFCOUNT时，即使在理论上处理密集型HyperLogLog的恒定时间很高，性能也很出色。这是可能的，因为PFCOUNT使用缓存来记住先前计算的基数，这种变化很少改变，因为大多数PFADD操作不会更新任何寄存器。每秒可能进行数百次操作。\n当使用多个键调用PFCOUNT时，会执行HyperLogLogs的即时合并，这很慢，而且无法缓存联合的基数，因此当与多个键一起使用时，PFCOUNT可能会花费一些时间。一个毫秒级的数量级，不应滥用。\n用户应记住，PFCOUNT 命令的单key和多keys执行在语义上是不同的，并且具有不同的性能。\n更多数据类型的用法请前往官网查看更多消息 https://redis.io/commands\n"});index.add({'id':21,'href':'/posts/redis/redis-version/','title':"Redis 版本信息",'content':"本文介绍 Redis发布周期, 版本兼容和版本特性说明\nRedis发布周期 Redis 作为系统软件，被各个系统广泛使用，升级会有一定成本，因此发布周期都比较长。\n unstable development frozen release candidate stable  版本兼容 Redis 尽量向后兼容，比如 2.8 通常向 2.6.x 兼容， 跨版本 2.4 则可能有问题。\n在主从配置中，虽然建议是 主从都是用相同的redis 版本， 但是实际使用中， 低版本的的主 2.6 通常可以接上 高版本的从 2.8;\n而高版本的主2.8 接上 低版本的从 2.6 可能有问题。\n版本说明 Redis 6.0 Redis 6在许多关键领域改进了Redis，并且是最大的领域之一，在此仅列出此版本的最大功能：\n 模块系统现在允许开发者使用新API，比如:\n将任意模块私有数据存储在RDB文件中，处理不同服务器事件，捕获和重写命令执行，阻止客户端key等 Redis重写了过期key的周期，可更快地收回过期key Redis全面支持SSL\nRedis现在在所有通道上都支持SSL 支持ACL\n可以指定某些用户只能运行某些命令或者访问某些数据结构 Redis提供了名为RESP3的新协议，该协议可返回更多语义答复\n客户端可以得到更明确的返回类型，客户端需要更新以支持此协议 服务器端支持键值的客户端缓存。\n这个该功能仍处于试验阶段，接下来的版本会有新的迭代，更多信息 https://redis.io/topics/client-side-caching Redis现在可以选择使用多线程来处理I/O，（最大128个线程）\n在单个实例中，每秒能共提供2倍的操作，但 pipeline 无法使用此功能 无硬盘复制现在支持从库，\nRedis版本2.8.18是支持无盘复制的第一个版本，支持主库直接同步， 现在则支持子进程直接在从库将RDB通过线路发送到从属设备，而不使用磁盘作为中间存储 Redis-benchmark 现在开始支持 Redis Cluster 模式 SRANDMEMBER 和其他相似的命令，有更好的随机性 改进了 Redis-cli 客户端 重写了 Systemd support 发布了 Redis Cluster 的代理服务\nhttps://github.com/artix75/redis-cluster-proxy 发布了 新的Redis module ： Disque，内存中的分布式作业队列\nhttps://github.com/antirez/disque-module  Redis 5.0 Redis 5是专注于一些重要功能的发行版。 而Redis 4非常专注于操作，\nRedis 5的更改大部分是面向用户的，在现有数据基础上实施新的数据类型和操作类型。 以下是此版本的主要功能：\n 支持 Stream 类型. https://redis.io/topics/streams-intro 增加 Redis Module API：计时器，集群和字典 API RDB 存储 LFU and LRU 信息 将集群管理器从Ruby（redis-trib.rb）由C改写，redis-cli --cluster help 查询更多帮助信息 sorted set 增加新操作命令: ZPOPMIN/ZPOPMAX （ blocking variants todo 未知） 升级碎片整理 version 2 HyperLogLog 优化底层实现 更好的内存报告功能。 子命令支持 HELP client 终端经常连接和断开会有更好的性能体现 修复若干bug，随机功能的性能提升 内存管理 Jemalloc 升级版本到 5.1 CLIENT UNBLOCK and CLIENT ID 添加 LOLWUT 功能（计算机美学，实际开发可能用不上） http://antirez.com/news/123 如果不是为了向后API兼容，Redis将不再使用“slave”一词 网络层中的Differnet优化 Lua的改进：  更好地将Lua脚本传输到 Slave(从库) / AOF(AOF追加操作落地) Lua脚本现在可以超时，并且处于BUSY状态的从库也支持   动态HZ，以平衡空闲CPU使用率和响应速度，\nhz理解为后台任务占用cpu资源 Redis核心在许多方面得到了重构和改进  Redis 4.0 Redis 3.2 Redis 3.0 Redis 2.8   现在，从站可以与主站部分重新同步，因此大多数情况下，当短短时间断开主从链接时，不需要与主端RDB创建完全重新同步\n  支持 IPv6 （实验性功能）\n  从站现在可以显式ping主机，主机可以独立检测超时的从站\n  可以设置如果没有连接足够多具有给定最大延迟的从站，则主站可以停止接受写操作\n  键空间通过发布/订阅更改通\n  CONFIG SET maxclients 现在可使用命令设置最大连接数\n  可以绑定多个ip地址\n  设置 进程\n  设置进程名称，以便您可以在“ ps”命令输出中识别实例的侦听端口，或者该实例是正在保存的子实例\n  崩溃时自动检查内存\n  CONFIG REWRITE可以将使用CONFIG SET操作的配置更改具体化到redis.conf文件中\n  NetBSD 更友好的代码库\n  PUBSUB命令用于发布/订阅自省功能， 列出相关信息，\n  现在可以照原样复制 EVALSHA，而无需为复制链接扩展到完整的EVAL LUA脚本(??)\n  更好的Lua脚本错误报告\n  SDIFF性能提升\n  实验特性： 无盘复制 http://redis.io/topics/replication\n  增加 SCAN, SSCAN, HSCAN, ZSCAN 命令\n  AOF 如果硬盘不够，则不会 异常退出，并且在硬盘足够的情况下，能够继续正常工作\n  增加 BITPOS: find first bit set or clear in a bitmap.\n  Redis-cli更新为使用SCAN而不是通过以下方式RANDOMKEY 进行随机采样\n  提升6倍 info 的速度\n  Jemalloc updated to 3.6.0\n  截断的 AOF 也可以重新加载\n  Redis 2.6  服务器端支持Lua脚本，请参阅http://redis.io/commands/eval 虚拟内存已删除（在2.4中已弃用） 删除了最大客户端数的硬编码限制， AOF低级语义通常更为理智，尤其是在使用 Slaves 增加毫秒级的过期策略，相关命令为 PEXPIRE, PTTL lists, ziplists hashes 小规模使用该类数据结构存储小数字，可以更好的利用内存 从库支持只读功能 新的 BIT 操作：BITCOUNT 和 BITOP 客户端最大输出缓冲区的软硬限制。您可以为不同类别的客户端（普通，pubsub，从库）指定不同的限制 更多增量（较少阻塞）的过期密钥收集算法，实际上，这意味着当大量密钥大约同时过期时，Redis的响应速度更快。 AOF 能够使用可变参数命令重写聚合数据类型，通常可以生成一个更易于保存，加载且尺寸更小的AOF 现在，每个redis.conf指令都可以作为redis-server二进制文件的命令行选项使用，并且具有相同的名称和参数数量。 散列表种子随机化，以防止冲突攻击。 将大型对象写入Redis时，性能得到改善 集成内存测试，请参阅redis-server \u0026ndash;test-memory 新增 INCRBYFLOAT and HINCRBYFLOAT 命令 新的DUMP，RESTORE，MIGRATE命令（从Redis Cluster移植回2.6） RDB文件中的CRC64 Checksump MONITOR 有更好的输出和行为（现在在执行之前已记录命令） Watchdog “看门狗”可调试延迟，慢日志等 CONFIG SET watchdog-period 500 重构或重写了核心的重要部分。新的内部API和核心更改允许在新代码的基础上开发Redis Cluster，但是对于2.6，所有集群代码均已删除，并且将在Redis 3.0更加完整和稳定时与Redis 3.0一起发布。 Redis 启动画面增加 ASCII logo 关于内存违规或失败的断言的崩溃报告得到了显着改进，从而使难以捕获的错误的调试更加简单。 redis-benchmark 提升: 能够运行选定的测试，CSV输出，更快，更好的帮助 redis-cli改进：\u0026ndash;eval用于舒适地开发Lua脚本 SHUTDOWN 现在支持两个可选参数：“SAVE”和“ NOSAVE” INFO输出分为多个部分，该命令现在仅能显示特定的部分 有关命令被调用多少时间以及使用了多少执行时间的新统计信息: info commandstats 在边缘情况下更可预测的SORT行为。 更好地支持大字节序和*BSD系统 改进了构建系统 "});index.add({'id':22,'href':'/posts/redis/redis-replication/','title':"Redis 主从复制",'content':"Redis 主从复制 主服复制功能，断开的话，从库会自动重新连接到从库。\n以下操作将会同步到从库\n 客户端写入数据，key过期或者强制删除数据任何其他更改主数据集的操作 当主服务器和副本服务器之间的链接断开时，由于网络问题或由于在主服务器或副本服务器中检测到超时，副本服务器将重新连接并尝试进行部分重新同步 如果无法进行部分重新同步，则副本将要求完全重新同步。这将涉及一个更复杂的过程，在该过程中，主服务器需要创建其所有数据的快照，将其发送到副本，然后在数据集更改时继续发送命令流。  默认情况下，主从复制是异步复制，（低延迟和高性能），可以支持同步复制，Sentinel或Redis Cluster 有更多高可用性和故障转移的信息。\n本文继续基本主从复制基本特征。\n Redis使用异步复制。 一个 Master可以有多个 Slave 。 Slave 支持级联， 所有的 Slave 将从 Master 获取相同的数据流。 非阻塞主从复制，同步的同时 Master 支持查询。 复制的同时 Slave 也基本上没有阻塞。\n执行初始同步时，Slave 可以使用旧版数据处理查询。否则，您可以配置Redis副本以在复制流关闭时将错误返回给客户端。 但是，在初始同步之后，必须删除旧的数据集，并且必须加载新的数据集。副本将在此短暂的窗口内阻止传入的连接（对于非常大的数据集，该连接可能长达数秒）。从Redis 4.0开始，可以对Redis进行配置，以在其他线程删除旧数据，但是加载新的初始数据集仍将在主线程中进行，并会阻塞 Slave。 主从复制可以用于可伸缩性，也可以用于只读查询的多个副本（例如，可以将慢速O（N）操作放在Slave），也可以只用作备份，用于提高数据安全性和高可用性，Slave 可以随之提升为 Master 主从复制有一个非常有用的用法：Master 关闭落盘逻辑，仅仅让Slave落盘，规避落盘带来的性能降低\nRDB数据大的时候容易出现问题，AOF是同步也会有性能\n但是，必须小心处理此设置，下面会讲，因为重新启动的 Master 将以空数据集开始：如果副本尝试与其同步，则副本也将被清空。  强烈建Master设置持久化  Master Redis 不能设置机器启动以后自动启动实例，可能导致以空数据启动导致所有的从都丢失数据   Redis复制如何工作 每个Master 都一个 ID，是一个较大的伪随机字符串，offset 表示复制流的偏移量（哪怕没有从库） Replication ID, offset\n\u0026gt;info Replication ole:master connected_slaves:0 master_replid:c4de5c0813d5d3aaf4f56b3d81c4edcd27824d7c master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0  确认Master id 和 offset 使用 PSYNC 发送旧的replid到最新的增量数据到 Slave  master 保存所有数据到 RDB 文件，并且开始缓存新到的命名数据流 传输 RDB 文件到 slave， 并且加载到内存 开始传输 之前缓存的命令数据流     如之前所说，主从复制断开是可以自动恢复的； 一主多从，只会执行一次 RDB 文件落盘；  连接到新提升的Master服务器的副本不必执行完全同步。\n无盘复制 通常，完全重新同步需要在磁盘上创建RDB文件，然后从磁盘重新加载相同的RDB，以便为副本提供数据。\n对于慢速磁盘，这对于Master而言可能是非常耗时的操作。 Redis 2.8.18版是第一个支持无盘复制的版本。 在此设置中，子进程直接通过线路将RDB发送到副本，而无需使用磁盘作为中间存储。\n配置主从 要配置基本的Redis复制很简单：只需将以下行添加到副本配置文件中：\nreplicaof 192.168.1.1 6379 配置只读 "});index.add({'id':23,'href':'/posts/mysql/6-mysql-design-rules/','title':"六、MySQL 建表原则",'content':"MySQL 建表原则， 常见面试题\n一、合适的数据类型 原则   更小的数据类型，不滥用类型\n占用更少的磁盘、内存、CPU缓存，CPU周期也更少\n  简单存储\nDataTime 存储日期和时间，而不是\u0026quot;字符串\u0026rdquo; 整型存储IP地址，而非字符串， INET_ATON / INET_NOTA\n  尽量避免 NULL 列如果可为 NULL，MySQL更难优化；\n如果该列需要索引，则需要更多空间；\n如果需要加索引，那么必须设置为 NOT NULL。\n  少列\n  少关联， 12表以内\n  更快地读，更慢地写，（读是大部分项目的大部分操作）\n  类型细节 整型\n TINYINT， SMALLINT， MEDIUMINT，INT，BIGINT INT(1)和INT(20) 存储相同，客户端显示字符个数  实数\n FLOAT,DOUBLE,DECIMAL DECIMAL 存储精确小数， 而计算时则转化为DOUBLE  字符串\n VARCHAR, CHAR 不定长字符串比定长更省资源。 CHAR 裁剪末尾空格； VARCHAR需要额外字节记录字符串长度； VARCHAR(5) 和 VARCHAR(20) 存储 \u0026lsquo;hello\u0026rsquo;, 存储开销一样， 但是后者内存消耗更多。  以下情况优先使用 VARCHAR\n 字符串的最大长度比平均长度大很多； 列更新少，因为经常更新容易碎片。 使用UTF-8 这样复杂的字符集, 每个字符都使用了不同字节数进行存储。  以下情况使用 CHAR\n CHAR 用来存储MD5这类定长的值。 经常更新的数据，因为定长，所以不容易产生碎片。 CHAR(1) 存储 Y / N  BLOB 和 TEXT\n用来存储很大的数据，分别是二进制和字符串形式存储。 Memory 引擎不支持该类型。\nTINYBLOB,SMALLBLOB,BLOB,MEDIUMBLOB, LONGBLOB\nBLOB = SMALLBLOB\nTEXT，同理\n实际存储，采用\u0026quot;外部\u0026quot;存储，列中存储指针。\n实际排序只采用， max_sort_length, 如果针对小部分排序，一个是减小 max_sort_length; 或者使用 ORDER by SUBSTRING(column, length).\nEXPLAIN，执行计划的Extra，包含 Using temporary， 说明使用了隐式临时表。 使用 枚举 ENUM 代替字符串类型, 节约空间，\n用在 重复度很高的地方，并且不会变化的地方，\n实际存储的是整型。\n 注意排序使用的整型，而不是实际的字符串。。。 所以需要按照顺序定义枚举\n关联表必须使用整数组件。\n时间\nDATETIME 范围大 1001-9999年\nTIMESTAMP 范围小，存储一半，效率高， 1907 - 2038年\n时间到秒， 但是计算是毫秒， 可以改为 MariaDB，或者使用 BIGINT 存储s，使用 DOUBLE 存储毫秒。\n位\nBIT\nSET\n范式和反范式  1NF，属性不可再分， (现在出现了sql，map这样的) 2NF，关联 3NF，  优点：\n 范式更新比反范式块 范式无重复数据 范式化表更小，操作更快 范式化，需要独立的表，不太需要使用 distinct 或者 group by； 反范式，冗余某些数据  缺点：\n 范式需要关联，可能导致索引策略无效。  注意范式和反范式的混合使用。\n缓存表和汇总表  缓存表，比如多张表关联查询的更少的字段。 汇总表，记录累计结果的。  定期维护数据，定期重建，解决碎片问题，处理有效的索引。\n可以使用\u0026quot;影子表\u0026rdquo;， 背后创建，结束了在使用重命名方式。\n加快ALTER TABLE 操作速度 影子拷贝， 工具有 Percona Toolkit.\n比如使用 ALTER COLUMN 替代 MODIFY COLUMN 来修改默认值。\n这种方法是修改 .frm 。\n以下操作不需要重建表\n remove 一个列的 auto_increment 属性， 增加，一处，或者更改ENUM和SET常量，  通过修改 .frm 文件来实现目的。\n快速创建 MyISAM 索引。。\n 禁用索引，载入数据，重新启用索引；\n不支持唯一索引， 删除索引记得保留唯一索引。  创建高性能索引 先理解索引。\n一、底层存储格式 1. B-Tree 索引 如果没有特殊说明，那么多半说的就是B-Tree索引类型。\nkey(姓, 名, 出生日期)\nkey(last_name, first_name, dob)\n最左前缀查找，以下是有效查询：\n 全值匹配\n姓 + 名 + 出生日期，全值匹配，第一列，第二列，第三列 匹配最左前缀\n姓， 只查看索引第一项 匹配列前缀\nsubstring(姓, 0, 1) 用到了第一列索引 匹配范围值\n姓\u0026gt;'allen\u0026rsquo; and 姓\u0026lt;'Barrymore\u0026rsquo; 用到了第一列索引 精确匹配某一列并范围匹配另外一列\n姓=='allen\u0026rsquo; and (名\u0026gt;'jelly\u0026rsquo; and 名\u0026lt;'rock\u0026rsquo;), 第一列全匹配，第二列范围匹配 只访问索引的查询 B-Tree 覆盖索引  同时，也支持 ORDER BY 这种类型。\nB-Tree 索引限制：\n 非最左列开始查找，则无法使用索引。比如无法查 姓\u0026rsquo;%oodjob\u0026rsquo;； 不能跳过索引中的列，比如，姓+出生日期，则只能用第一列索引； 查询了某一列的范围，则右边的列，都无法使用索引；  索引只能做等于，不等于以及大于小于操作， 而字符串的最左前缀匹配的LIKE查询，其实是转化成了简单的比较操作。\n2. HASH 索引 hash 表实现， 精确匹配索引所有的列查询才有效。 非常快； Memory 表中默认类型， 也支持B-Tree\n限制：\n 哈希哈希只包含哈希值和行指针， 不能用来避免读取行。 无法用来排序。 不可使用部分索引，HASH(A,B)， 必须AB两列都要查询。 只能用来等值查询 = , IN, \u0026lt;=\u0026gt;(与NULL值的比较) , 多哈希相同，则找出所有的，然后遍历； 冲突多，维护的代价也很高，比如删除；  适用于限定场合， 数据仓库中经典的 星型 schema，需要关联很多查找表。可以使用 哈希索引；\n自适应哈希索引：\nInnoDB 注意到某些索引用的很频繁，则再次智商在创建一个哈希索引。是一个自动的，内部的行为， 无法控制，但是可开关。\n创建自定义哈希索引\nurl作为长字符串，使用B-Tree，索引太麻烦，如果常用的全职匹配，则可以增加一列，比如 url_crc， 值是经过 crc32 哈希之后在入库， 之后查询就是 where url_crc=CRC32(\u0026lsquo;http://goodjob.com\u0026rsquo;);\n非常高效。 可以使用触发器。\n3. 全文索引 // todo\n二、高性能索引策略 独立的列 使用的索引列不能是表达式的一部分，也不能是函数的参数。\n前缀索引和索引选择性 有时索引很长的字符串，一个策略是 哈希索引，另外一个策略是索引开始的部分字符。\n计算前缀可能性， 需要有一定量的数据， 然后通过一个公式， n=长度， f(n) 约等于 0.031 ，这个长度 n 的索引就够用了。\nselect count(distinct left(city,3))/count(*) as sel3, count(distinct left(city,4))/count(*) as sel4, count(distinct left(city,5))/count(*) as sel5, count(distinct left(city,6))/count(*) as sel6, count(distinct left(city,7))/count(*) as sel7 from test.test; 优点：\n更小，更快\n缺点：\n无法使用前缀索引作 ORDER BY 和 GROUP BY， 也无法做覆盖扫描。 // todo\n后缀索引，也有用，比如某个公司的邮箱， mysql 不支持后缀索引，这时，可以先反转字符串。\n多列索引 多个列上建立单独的单列索引大部分情况下并不能提高查询性能。\n对InnoDB来说，主键已经包含在二级索引中， 有了key(A), 那么 key(A,ID) 则不需要。\n索引上的OR， 可以改成 UNION ALL，\nmysql 内部会使用索引合并策略，这是一种优化结果，也说明索引建的很糟糕。 但是优化器，不如使用 UNION ALL；\n索引列顺序（针对B-Tree） ORDER BY，GROUP BY 和 DISTINCT 子句的查询需求。\n经验之谈：\n通常不考虑排序和分组时，把选择性最高的列放到索引的最前列。\n全局基数和选择性。\n对某些特殊情况可能需要禁止查询。\n聚簇索引 数据行和索引存放在一起。只能有一个索引聚簇数据，\n索引中访问数据更快。\n缺点：\n 提升I/O密集型应用性能。在内存中没有什么优势； 插入速度依赖插入顺序，非按照主键顺序插入，则需要使用 OPTIMIZE TABLE 重新组织以下表。  只查询列的数据，已经包含在索引中，称之为\u0026quot;覆盖索引\u0026rdquo;。 只有B-Tree 索引做覆盖索引。\n如果Explain 的 Extra 看到 Using index，如果只访问 key 中的列，则可以用做覆盖索引。\n设计索引完成查找和排序 排序操作 和 索引顺序扫描 可以得到有序结果。\nExplain 中 type == index， 说明通过索引扫描来排序。 （Extra using index ，说明用到了覆盖索引）。\n索引列的顺序和ORDER By子句的顺序完全一致，并且所有列的方向（倒序，正序）都一样时，Mysql才能使用索引对结果做排序。\n如果多表关联，则Order By 子句必须全部为第一张表时，才可以使用索引排序。\n多列索引A,B,C中，如果where 或者 join 指定A 为常量，则 ORDRE BY B,C 是可以使用索引排序的。\nA条件 有范围查找，则不能只用B排序。 // 待考证。todo\n压缩（前缀压缩）索引 MyISAM 使用前缀压缩来减少索引大小，代价则是某些操作更慢，时间换空间。\nORDER BY DESC 倒序扫描就不是很好。\n todo 区分 I/O 密集和 CPU 密集。\n冗余和重复索引，未使用到的索引 MySQL 需要单独维护重复索引，并在优化器上也要逐个考虑，会影响性能。\nMySQL 唯一键和主键限制都是通过索引实现的，不需要重复建立。\n而冗余索引则不同。\nkey(A,B) 和 key(A) 就是冗余\nkey(A,B) 和 key(B, A) 就是不是冗余\n冗余可能发生在，对key(A) 进行扩展，但不是修改Key，而是新增 KEY(A,B).\n还有一种永远用不到的索引，完全是累赘，考虑删除。 有工具来定位。\npt-index-usage.\n索引和锁 索引可以让查询锁定更少的行。\nInnoDB 的行锁效率很高，但是锁定行会带来额外的开销。锁定超过需要行会增加锁争夺，减少并发性。\nMySQL 在服务端才能应用WHERE 子句。\nInnoDB， 在二级索引使用共享锁/读锁， 主键是写锁。\n只有InnoDB在存储引擎层能够过滤掉不需要的行时才有效，没有使用到索引，则照样需要锁表。\nselect aid from bb where aid \u0026lt; 5 and aid \u0026lt;\u0026gt; 1 for update; 这个sql会锁定 ，1 2 3 4行，为什么会锁定1行，因为索引只用在了 aid \u0026lt; 5 子句， aid\u0026lt;\u0026gt;1 这个子句 \u0026lt;\u0026gt; 是不能使用索引的。\n为了验证行锁情况， 开启事务之前 关闭 AUTOCOMMIT。\nSET AUTOCOMMIT=0; BEGIN;\n索引实战 列：国家、地区、城市、性别、肤色、年龄。\n国家和性别，选择性通常不高，但是很多查询都会用到。所以依然使用 (性别，国家)来作为前缀。\n但是根据最左前缀，这貌似不理智。\n可以使用某些诀窍过滤， 条件中增加 SEX IN (\u0026rsquo;m\u0026rsquo;, \u0026lsquo;f\u0026rsquo;) 虽然没有过滤任何行，但是依然会让索引生效。 但是 列有太多不同的值，就会让IN 表太长，就不合适了。\n我们常常把年龄放在索引的后面，因为年龄常常是范围查找，而在范围查找之后，不能再使用索引了， 所以，范围查找放在后面，（当然也可以改写为 IN(18,19,20,21,22) 这样的枚举方式）\n但是千万不可滥用 IN， IN会转化成 24 组合。\n避免多个范围条件，EXPLAIN 中的 type == range\nlimit 操作是在 server 处理。\n延迟关联，用上覆盖索引，使用了主键，然后根据主键来关联。\n碎片处理， Optimize table alter table 修改 存储引擎为当前引擎。\nEXPLAIN 关注类型 select_type: type: key: key_len: rows: Extra: Extra：\n Using where，说明返回了结果到 server 层后还做了过滤。 Using index, 说明使用了覆盖索引。 "});index.add({'id':24,'href':'/posts/redis/redis-transaction/','title':"Redis 事务",'content':"Redis 事务 Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。  一个事务从开始到执行会经历以下三个阶段：\n 开始事务。 命令入队。 执行事务。   实例 以下是一个事务的例子， 它先以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令：\nredis 127.0.0.1:6379\u0026gt; MULTI OK redis 127.0.0.1:6379\u0026gt; SET book-name \u0026quot;Mastering C++ in 21 days\u0026quot; QUEUED redis 127.0.0.1:6379\u0026gt; GET book-name QUEUED redis 127.0.0.1:6379\u0026gt; SADD tag \u0026quot;C++\u0026quot; \u0026quot;Programming\u0026quot; \u0026quot;Mastering Series\u0026quot; QUEUED redis 127.0.0.1:6379\u0026gt; SMEMBERS tag QUEUED redis 127.0.0.1:6379\u0026gt; EXEC 1) OK 2) \u0026quot;Mastering C++ in 21 days\u0026quot; 3) (integer) 3 4) 1) \u0026quot;Mastering Series\u0026quot; 2) \u0026quot;C++\u0026quot; 3) \u0026quot;Programming\u0026quot;  Redis 事务命令 下表列出了 redis 事务的相关命令：\n   序号 命令及描述     1 DISCARD 取消事务，放弃执行事务块内的所有命令。   2 EXEC 执行所有事务块内的命令。   3 MULTI 标记一个事务块的开始。   4 UNWATCH 取消 WATCH 命令对所有 key 的监视。   5 WATCH key [key \u0026hellip;] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。   "});index.add({'id':25,'href':'/posts/mysql/7-mysql-profiling/','title':"七、Mysql 性能问题定位",'content':"本文介绍 Mysql 性能问题定位。\n慢查询日志 和 Percona Toolkit pt-query-digest\nhttps://www.percona.com/doc/percona-toolkit/2.2/installation.html\n定义 性能： 完成某件任务所需要的时间度量。\n根据 amdahl 阿姆达尔定律，要想获得性能有效提升，必须优先优化最耗时的部分。\n所以做性能优化最重要的是测量响应时间花在哪里，以及为什么花在哪里。\nwhere and why\n任务耗时可以分两部分：执行时间和等待时间\n 执行时间： 最好的方法是测量定位不同的子任务花费的时间。对子任务进行优化效率/去掉/降低频率操作； 等待时间：复杂一点，可能是系统其他任务间接影响， 磁盘/CPU资源。  千万不要试图通过某些方法修改参数，什么的试错的方式来看有没有可能解决问题。可能会变得更糟糕，比如没有足够理由地升级版本。\n剖析步骤 找到慢 SQL  慢查询  一定要开，注意旋转，I/O无影响，CPU密集型受到影响更大 分析工具： pt-query-digest    书本 p 92 页， awk 语句 show full processlist; 粗粒度 Percona Toolkit  剖析单个 SQL 1、 show profiles\nmysql\u0026gt; set profiling = 1; mysql\u0026gt; show profiles; mysql\u0026gt; show profile for query 1; 不能 排序。 用sql 转化， 见 83 页 2、 show status\nshow status where Variable_name like \u0026#39;Handler%\u0026#39; or Variable_name like \u0026#39;Created%\u0026#39;; 3、EXPLAIN 查询执行计划， 检查索引使用情况， 4、尝试修改WHERE排查命中缓存情况，\n单个sql还是服务器问题 慢查询是否表现一致，是，服务器问题，否，单sql问题。\nshow global status todo P97\nshow processlist 偶发问题 Threads_running 的趋势可以看出问题所在；\nshow processlist 中线程的异常状态尖峰也是不错的指标；\n$mysql -e \u0026#39;show processlist \\G\u0026#39; | grep -c \u0026#34;State: freeing items\u0026#34; show innodb status 特定输出：\n服务器的平均负载尖峰。\nPercona Toolkit 的 pt-stalk\noprofile linux 内置的性能工具。 strace 剖析服务器的系统调用， （生产环境有一定风险）。\ntcpdump 来监听慢查询，（如果不能打开慢查询日志）。\n问题采集  查询：  索引扫描 范围扫描 全表扫描 表关联查询   每秒排序次数和行数 临时表  临时表数量 内存临时表还是磁盘临时表(超过 tmp_table_size max_heap_table_size)   锁 lock table innodb的查询缓存问题 show innodb status 每秒捕获一次 iostat， 持续30s vmstat 检查 "});index.add({'id':26,'href':'/posts/redis/redis-pipelined/','title':"Redis pipelined 管道",'content':"Redis pipelined 管道 Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：\n 客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。 服务端处理命令，并将结果返回给客户端。   Redis 管道技术 Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。\n实例 查看 redis 管道，只需要启动 redis 实例并输入以下命令：\n$(echo -en \u0026quot;PING\\r\\n SET w3ckey redis\\r\\nGET w3ckey\\r\\nINCR visitor\\r\\nINCR visitor\\r\\nINCR visitor\\r\\n\u0026quot;; sleep 10) | nc localhost 6379 +PONG +OK redis :1 :2 :3 以上实例中我们通过使用 PING 命令查看redis服务是否可用， 之后我们们设置了 w3ckey 的值为 redis，然后我们获取 w3ckey 的值并使得 visitor 自增 3 次。\n在返回的结果中我们可以看到这些命令一次性向 redis 服务提交，并最终一次性读取所有服务端的响应\n 管道技术的优势 管道技术最显著的优势是提高了 redis 服务的性能。\n一些测试数据 在下面的测试中，我们将使用Redis的Ruby客户端，支持管道技术特性，测试管道技术对速度的提升效果。\nrequire 'rubygems' require 'redis' def bench(descr) start = Time.now yield puts \u0026quot;#{descr} #{Time.now-start} seconds\u0026quot; end def without_pipelining r = Redis.new 10000.times { r.ping } end def with_pipelining r = Redis.new r.pipelined { 10000.times { r.ping } } end bench(\u0026quot;without pipelining\u0026quot;) { without_pipelining } bench(\u0026quot;with pipelining\u0026quot;) { with_pipelining } 从处于局域网中的Mac OS X系统上执行上面这个简单脚本的数据表明，开启了管道操作后，往返时延已经被改善得相当低了。\nwithout pipelining 1.185238 seconds with pipelining 0.250783 seconds 如你所见，开启管道后，我们的速度效率提升了5倍。\n"});index.add({'id':27,'href':'/posts/redis/redis-rdb-aof/','title':"Redis 持久化方式RDB和AOF比较",'content':"Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。\nRDB和AOF工作方式 RDB RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。\nAOF AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。\nRDB优缺点 RDB存在哪些优势呢？   一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数 据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。\n  对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。\n  性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。\n  相比于AOF机制，如果数据集很大，RDB的启动效率会更高。\n  RDB又存在哪些劣势呢？   如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。\n  由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。\n  AOF优缺点 AOF的优势有哪些呢？   该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其 效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变 化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。\n  由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操 作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据 一致性的问题。\n  如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创 建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。\n  AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。\n  AOF的劣势有哪些呢？   对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。\n  根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。 二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。\n "});index.add({'id':28,'href':'/posts/redis/redis-module/','title':"Redis Module 模块",'content':"todo\n"});index.add({'id':29,'href':'/posts/mysql/10-mysql-version/','title':"十、Mysql 版本信息",'content':"本文介绍 Mysql 发布周期, 版本兼容和版本特性说明\n"});index.add({'id':30,'href':'/docs/example/table-of-contents/','title':"Table of Contents",'content':"Ubi loqui Mentem genus facietque salire tempus bracchia Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':31,'href':'/docs/example/collapsed/','title':"Collapsed",'content':"Collapsed Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':32,'href':'/','title':"X",'content':"Fence X 后端研发工程师    Do not go gentle into that good night   邮箱\nyagoodidea@gmail.com  网站\nfencex.github.io  个人技能  Web方向\nGo  PHP  Java  MySQL  Redis  高并发  大数据方向\nScala  Spark  Hive  Ambari  Flink  ...    "});index.add({'id':33,'href':'/posts/','title':"随笔",'content':""});index.add({'id':34,'href':'/categories/','title':"Categories",'content':""});index.add({'id':35,'href':'/categories/security/','title':"security",'content':""});index.add({'id':36,'href':'/tags/','title':"Tags",'content':""});index.add({'id':37,'href':'/tags/web/','title':"web",'content':""});index.add({'id':38,'href':'/categories/web/','title':"web",'content':""});index.add({'id':39,'href':'/posts/csp/','title':"内容安全策略Content Security Policy",'content':""});index.add({'id':40,'href':'/tags/redis/','title':"redis",'content':""});index.add({'id':41,'href':'/categories/redis/','title':"redis",'content':""});index.add({'id':42,'href':'/posts/redis/','title':"Redis 博客",'content':""});index.add({'id':43,'href':'/tags/golang/','title':"golang",'content':""});index.add({'id':44,'href':'/categories/golang/','title':"golang",'content':""});index.add({'id':45,'href':'/categories/develop/','title':"develop",'content':""});index.add({'id':46,'href':'/tags/git/','title':"git",'content':""});index.add({'id':47,'href':'/categories/git/','title':"git",'content':""});index.add({'id':48,'href':'/posts/tools/git/git-refresh-commit-email/','title':"git重刷提交的email和name信息",'content':"场景  公司项目和个人项目不能耦合特别是发布到公开项目的“提交人”信息最好不要和公司一致；\n但，难免忘记配置，需要重新刷；\n推荐的方式是，放弃全局配置，每个项目独立配置 user.name user.email\n步骤 1. 克隆bare项目 纯仓库 git clone --bare https://github.com/user/repo.git cd repo.git 2. 修改信息 #!/bin/sh git filter-branch --env-filter \u0026#39; OLD_EMAIL=\u0026#34;old@email.com\u0026#34; CORRECT_NAME=\u0026#34;new_name\u0026#34; CORRECT_EMAIL=\u0026#34;new@email.com\u0026#34; if [ \u0026#34;$GIT_COMMITTER_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_COMMITTER_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_COMMITTER_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi if [ \u0026#34;$GIT_AUTHOR_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_AUTHOR_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_AUTHOR_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi \u0026#39; --tag-name-filter cat -- --branches --tags 3. 修正的任务推送到远程 git push --force --tags origin \u0026#39;refs/heads/*\u0026#39; 4. 清理多余文件 cd .. rm -rf repo.git "});index.add({'id':49,'href':'/categories/bigdata/','title':"bigdata",'content':""});index.add({'id':50,'href':'/posts/cheatsheet/golang/golang-1/','title':"Go编程语言规范",'content':"简介 这是Go编程语言的参考手册。 有关更多信息和其他文档，请访问https://golang.org。\nGo是一种通用语言，设计时考虑了系统编程。 它是强类型的并且是垃圾回收的，并且对并发编程有明确的支持。 程序是由程序包构造的，程序包的属性可以有效地管理依赖关系。\n语法紧凑且易于解析，可通过集成开发环境等自动工具轻松进行分析。\nNotation The syntax is specified using Extended Backus-Naur Form (EBNF):\nProduction = production_name \u0026quot;=\u0026quot; [ Expression ] \u0026quot;.\u0026quot; . Expression = Alternative { \u0026quot;|\u0026quot; Alternative } . Alternative = Term { Term } . Term = production_name | token [ \u0026quot;…\u0026quot; token ] | Group | Option | Repetition . Group = \u0026quot;(\u0026quot; Expression \u0026quot;)\u0026quot; . Option = \u0026quot;[\u0026quot; Expression \u0026quot;]\u0026quot; . Repetition = \u0026quot;{\u0026quot; Expression \u0026quot;}\u0026quot; . Productions are expressions constructed from terms and the following operators, in increasing precedence:\n| alternation () grouping [] option (0 or 1 times) {} repetition (0 to n times) Lower-case production names are used to identify lexical tokens. Non-terminals are in CamelCase. Lexical tokens are enclosed in double quotes \u0026quot;\u0026quot; or back quotes ````.\nThe form a … b represents the set of characters from a through b as alternatives. The horizontal ellipsis … is also used elsewhere in the spec to informally denote various enumerations or code snippets that are not further specified. The character … (as opposed to the three characters ...) is not a token of the Go language.\nSource code representation Source code is Unicode text encoded in UTF-8. The text is not canonicalized, so a single accented code point is distinct from the same character constructed from combining an accent and a letter; those are treated as two code points. For simplicity, this document will use the unqualified term character to refer to a Unicode code point in the source text.\nEach code point is distinct; for instance, upper and lower case letters are different characters.\nImplementation restriction: For compatibility with other tools, a compiler may disallow the NUL character (U+0000) in the source text.\nImplementation restriction: For compatibility with other tools, a compiler may ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark may be disallowed anywhere else in the source.\nCharacters The following terms are used to denote specific Unicode character classes:\nnewline = /* the Unicode code point U+000A */ . unicode_char = /* an arbitrary Unicode code point except newline */ . unicode_letter = /* a Unicode code point classified as \u0026quot;Letter\u0026quot; */ . unicode_digit = /* a Unicode code point classified as \u0026quot;Number, decimal digit\u0026quot; */ . In The Unicode Standard 8.0, Section 4.5 \u0026ldquo;General Category\u0026rdquo; defines a set of character categories. Go treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo as Unicode letters, and those in the Number category Nd as Unicode digits.\nLetters and digits The underscore character _ (U+005F) is considered a letter.\nletter = unicode_letter | \u0026quot;_\u0026quot; . decimal_digit = \u0026quot;0\u0026quot; … \u0026quot;9\u0026quot; . binary_digit = \u0026quot;0\u0026quot; | \u0026quot;1\u0026quot; . octal_digit = \u0026quot;0\u0026quot; … \u0026quot;7\u0026quot; . hex_digit = \u0026quot;0\u0026quot; … \u0026quot;9\u0026quot; | \u0026quot;A\u0026quot; … \u0026quot;F\u0026quot; | \u0026quot;a\u0026quot; … \u0026quot;f\u0026quot; . Lexical elements Comments Comments serve as program documentation. There are two forms:\n Line comments start with the character sequence // and stop at the end of the line. General comments start with the character sequence /* and stop with the first subsequent character sequence */.  A comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline.\nTokens Tokens form the vocabulary of the Go language. There are four classes: identifiers, keywords, operators and punctuation, and literals. White space, formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns (U+000D), and newlines (U+000A), is ignored except as it separates tokens that would otherwise combine into a single token. Also, a newline or end of file may trigger the insertion of a semicolon. While breaking the input into tokens, the next token is the longest sequence of characters that form a valid token.\nSemicolons The formal grammar uses semicolons \u0026quot;;\u0026quot; as terminators in a number of productions. Go programs may omit most of these semicolons using the following two rules:\n When the input is broken into tokens, a semicolon is automatically inserted into the token stream immediately after a line\u0026rsquo;s final token if that token is  an identifier an integer, floating-point, imaginary, rune, or string literal one of the keywords break, continue, fallthrough, or return one of the operators and punctuation ++, --, ), ], or }   To allow complex statements to occupy a single line, a semicolon may be omitted before a closing \u0026quot;)\u0026quot; or \u0026quot;}\u0026quot;.  To reflect idiomatic use, code examples in this document elide semicolons using these rules.\nIdentifiers Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.\nidentifier = letter { letter | unicode_digit } . a _x9 ThisVariableIsExported αβ Some identifiers are predeclared.\nKeywords The following keywords are reserved and may not be used as identifiers.\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var Operators and punctuation The following character sequences represent operators (including assignment operators) and punctuation:\n+ \u0026amp; += \u0026amp;= \u0026amp;\u0026amp; == != ( ) - | -= |= || \u0026lt; \u0026lt;= [ ] * ^ *= ^= \u0026lt;- \u0026gt; \u0026gt;= { } / \u0026lt;\u0026lt; /= \u0026lt;\u0026lt;= ++ = := , ; % \u0026gt;\u0026gt; %= \u0026gt;\u0026gt;= -- ! ... . : \u0026amp;^ \u0026amp;^= Integer literals An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15.\nFor readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal\u0026rsquo;s value.\nint_lit = decimal_lit | binary_lit | octal_lit | hex_lit . decimal_lit = \u0026quot;0\u0026quot; | ( \u0026quot;1\u0026quot; … \u0026quot;9\u0026quot; ) [ [ \u0026quot;_\u0026quot; ] decimal_digits ] . binary_lit = \u0026quot;0\u0026quot; ( \u0026quot;b\u0026quot; | \u0026quot;B\u0026quot; ) [ \u0026quot;_\u0026quot; ] binary_digits . octal_lit = \u0026quot;0\u0026quot; [ \u0026quot;o\u0026quot; | \u0026quot;O\u0026quot; ] [ \u0026quot;_\u0026quot; ] octal_digits . hex_lit = \u0026quot;0\u0026quot; ( \u0026quot;x\u0026quot; | \u0026quot;X\u0026quot; ) [ \u0026quot;_\u0026quot; ] hex_digits . decimal_digits = decimal_digit { [ \u0026quot;_\u0026quot; ] decimal_digit } . binary_digits = binary_digit { [ \u0026quot;_\u0026quot; ] binary_digit } . octal_digits = octal_digit { [ \u0026quot;_\u0026quot; ] octal_digit } . hex_digits = hex_digit { [ \u0026quot;_\u0026quot; ] hex_digit } . 42 4_2 0600 0_600 0o600 0O600 // second character is capital letter 'O' 0xBadFace 0xBad_Face 0x_67_7a_2f_cc_40_c6 170141183460469231731687303715884105727 170_141183_460469_231731_687303_715884_105727 _42 // an identifier, not an integer literal 42_ // invalid: _ must separate successive digits 4__2 // invalid: only one _ at a time 0_xBadFace // invalid: _ must separate successive digits Floating-point literals A floating-point literal is a decimal or hexadecimal representation of a floating-point constant.\nA decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp.\nA hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 §5.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp.\nFor readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value.\nfloat_lit = decimal_float_lit | hex_float_lit . decimal_float_lit = decimal_digits \u0026quot;.\u0026quot; [ decimal_digits ] [ decimal_exponent ] | decimal_digits decimal_exponent | \u0026quot;.\u0026quot; decimal_digits [ decimal_exponent ] . decimal_exponent = ( \u0026quot;e\u0026quot; | \u0026quot;E\u0026quot; ) [ \u0026quot;+\u0026quot; | \u0026quot;-\u0026quot; ] decimal_digits . hex_float_lit = \u0026quot;0\u0026quot; ( \u0026quot;x\u0026quot; | \u0026quot;X\u0026quot; ) hex_mantissa hex_exponent . hex_mantissa = [ \u0026quot;_\u0026quot; ] hex_digits \u0026quot;.\u0026quot; [ hex_digits ] | [ \u0026quot;_\u0026quot; ] hex_digits | \u0026quot;.\u0026quot; hex_digits . hex_exponent = ( \u0026quot;p\u0026quot; | \u0026quot;P\u0026quot; ) [ \u0026quot;+\u0026quot; | \u0026quot;-\u0026quot; ] decimal_digits . 0. 72.40 072.40 // == 72.40 2.71828 1.e+0 6.67428e-11 1E6 .25 .12345E+5 1_5. // == 15.0 0.15e+0_2 // == 15.0 0x1p-2 // == 0.25 0x2.p10 // == 2048.0 0x1.Fp+0 // == 1.9375 0X.8p-0 // == 0.5 0X_1FFFP-16 // == 0.1249847412109375 0x15e-2 // == 0x15e - 2 (integer subtraction) 0x.p1 // invalid: mantissa has no digits 1p-2 // invalid: p exponent requires hexadecimal mantissa 0x1.5e-2 // invalid: hexadecimal mantissa requires p exponent 1_.5 // invalid: _ must separate successive digits 1._5 // invalid: _ must separate successive digits 1.5_e1 // invalid: _ must separate successive digits 1.5e_1 // invalid: _ must separate successive digits 1.5e1_ // invalid: _ must separate successive digits Imaginary literals An imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lower-case letter i. The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i.\nimaginary_lit = (decimal_digits | int_lit | float_lit) \u0026quot;i\u0026quot; . For backward compatibility, an imaginary literal\u0026rsquo;s integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading 0.\n0i 0123i // == 123i for backward-compatibility 0o123i // == 0o123 * 1i == 83i 0xabci // == 0xabc * 1i == 2748i 0.i 2.71828i 1.e+0i 6.67428e-11i 1E6i .25i .12345E+5i 0x1p-2i // == 0x1p-2 * 1i == 0.25i Rune literals A rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in 'x' or '\\n'. Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats.\nThe simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal 'a' holds a single byte representing a literal a, Unicode U+0061, value 0x61, while 'ä' holds two bytes (0xc3 0xa4) representing a literal a-dieresis, U+00E4, value 0xe4.\nSeveral backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: \\x followed by exactly two hexadecimal digits; \\u followed by exactly four hexadecimal digits; \\U followed by exactly eight hexadecimal digits, and a plain backslash \\ followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base.\nAlthough these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes \\u and \\U represent Unicode code points so within them some values are illegal, in particular those above 0x10FFFF and surrogate halves.\nAfter a backslash, certain single-character escapes represent special values:\n\\a U+0007 alert or bell \\b U+0008 backspace \\f U+000C form feed \\n U+000A line feed or newline \\r U+000D carriage return \\t U+0009 horizontal tab \\v U+000b vertical tab \\\\ U+005c backslash \\' U+0027 single quote (valid escape only within rune literals) \\\u0026quot; U+0022 double quote (valid escape only within string literals) All other sequences starting with a backslash are illegal inside rune literals.\nrune_lit = \u0026quot;'\u0026quot; ( unicode_value | byte_value ) \u0026quot;'\u0026quot; . unicode_value = unicode_char | little_u_value | big_u_value | escaped_char . byte_value = octal_byte_value | hex_byte_value . octal_byte_value = `\\` octal_digit octal_digit octal_digit . hex_byte_value = `\\` \u0026quot;x\u0026quot; hex_digit hex_digit . little_u_value = `\\` \u0026quot;u\u0026quot; hex_digit hex_digit hex_digit hex_digit . big_u_value = `\\` \u0026quot;U\u0026quot; hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit . escaped_char = `\\` ( \u0026quot;a\u0026quot; | \u0026quot;b\u0026quot; | \u0026quot;f\u0026quot; | \u0026quot;n\u0026quot; | \u0026quot;r\u0026quot; | \u0026quot;t\u0026quot; | \u0026quot;v\u0026quot; | `\\` | \u0026quot;'\u0026quot; | `\u0026quot;` ) . 'a' 'ä' '本' '\\t' '\\000' '\\007' '\\377' '\\x07' '\\xff' '\\u12e4' '\\U00101234' '\\'' // rune literal containing single quote character 'aa' // illegal: too many characters '\\xa' // illegal: too few hexadecimal digits '\\0' // illegal: too few octal digits '\\uDFFF' // illegal: surrogate half '\\U00110000' // illegal: invalid Unicode code point String literals A string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals.\nRaw string literals are character sequences between back quotes, as in foo. Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\r\u0026rsquo;) inside raw string literals are discarded from the raw string value.\nInterpreted string literals are character sequences between double quotes, as in \u0026quot;bar\u0026quot;. Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that \\' is illegal and \\\u0026quot; is legal), with the same restrictions. The three-digit octal (\\nnn) and two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\377 and \\xFF represent a single byte of value 0xFF=255, while ÿ, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF.\nstring_lit = raw_string_lit | interpreted_string_lit . raw_string_lit = \u0026quot;`\u0026quot; { unicode_char | newline } \u0026quot;`\u0026quot; . interpreted_string_lit = `\u0026quot;` { unicode_value | byte_value } `\u0026quot;` . `abc` // same as \u0026quot;abc\u0026quot; `\\n \\n` // same as \u0026quot;\\\\n\\n\\\\n\u0026quot; \u0026quot;\\n\u0026quot; \u0026quot;\\\u0026quot;\u0026quot; // same as `\u0026quot;` \u0026quot;Hello, world!\\n\u0026quot; \u0026quot;日本語\u0026quot; \u0026quot;\\u65e5本\\U00008a9e\u0026quot; \u0026quot;\\xff\\u00FF\u0026quot; \u0026quot;\\uD800\u0026quot; // illegal: surrogate half \u0026quot;\\U00110000\u0026quot; // illegal: invalid Unicode code point These examples all represent the same string:\n\u0026quot;日本語\u0026quot; // UTF-8 input text `日本語` // UTF-8 input text as a raw literal \u0026quot;\\u65e5\\u672c\\u8a9e\u0026quot; // the explicit Unicode code points \u0026quot;\\U000065e5\\U0000672c\\U00008a9e\u0026quot; // the explicit Unicode code points \u0026quot;\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\u0026quot; // the explicit UTF-8 bytes If the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal.\nConstants There are boolean constants, rune constants, integer constants, floating-point constants, complex constants, and string constants. Rune, integer, floating-point, and complex constants are collectively called numeric constants.\nA constant value is represented by a rune, integer, floating-point, imaginary, or string literal, an identifier denoting a constant, a constant expression, a conversion with a result that is a constant, or the result value of some built-in functions such as unsafe.Sizeof applied to any value, cap or len applied to some expressions, real and imag applied to a complex constant and complex applied to numeric constants. The boolean truth values are represented by the predeclared constants true and false. The predeclared identifier iota denotes an integer constant.\nIn general, complex constants are a form of constant expression and are discussed in that section.\nNumeric constants represent exact values of arbitrary precision and do not overflow. Consequently, there are no constants denoting the IEEE-754 negative zero, infinity, and not-a-number values.\nConstants may be typed or untyped. Literal constants, true, false, iota, and certain constant expressions containing only untyped constant operands are untyped.\nA constant may be given a type explicitly by a constant declaration or conversion, or implicitly when used in a variable declaration or an assignment or as an operand in an expression. It is an error if the constant value cannot be represented as a value of the respective type.\nAn untyped constant has a default type which is the type to which the constant is implicitly converted in contexts where a typed value is required, for instance, in a short variable declaration such as i := 0 where there is no explicit type. The default type of an untyped constant is bool, rune, int, float64, complex128 or string respectively, depending on whether it is a boolean, rune, integer, floating-point, complex, or string constant.\nImplementation restriction: Although numeric constants have arbitrary precision in the language, a compiler may implement them using an internal representation with limited precision. That said, every implementation must:\n Represent integer constants with at least 256 bits. Represent floating-point constants, including the parts of a complex constant, with a mantissa of at least 256 bits and a signed binary exponent of at least 16 bits. Give an error if unable to represent an integer constant precisely. Give an error if unable to represent a floating-point or complex constant due to overflow. Round to the nearest representable constant if unable to represent a floating-point or complex constant due to limits on precision.  These requirements apply both to literal constants and to the result of evaluating constant expressions.\nVariables A variable is a storage location for holding a value. The set of permissible values is determined by the variable\u0026rsquo;s type.\nA variable declaration or, for function parameters and results, the signature of a function declaration or function literal reserves storage for a named variable. Calling the built-in function new or taking the address of a composite literal allocates storage for a variable at run time. Such an anonymous variable is referred to via a (possibly implicit) pointer indirection.\nStructured variables of array, slice, and struct types have elements and fields that may be addressed individually. Each such element acts like a variable.\nThe static type (or just type) of a variable is the type given in its declaration, the type provided in the new call or composite literal, or the type of an element of a structured variable. Variables of interface type also have a distinct dynamic type, which is the concrete type of the value assigned to the variable at run time (unless the value is the predeclared identifier nil, which has no type). The dynamic type may vary during execution but values stored in interface variables are always assignable to the static type of the variable.\nvar x interface{} // x is nil and has static type interface{} var v *T // v has value nil, static type *T x = 42 // x has value 42 and dynamic type int x = v // x has value (*T)(nil) and dynamic type *T A variable\u0026rsquo;s value is retrieved by referring to the variable in an expression; it is the most recent value assigned to the variable. If a variable has not yet been assigned a value, its value is the zero value for its type.\nTypes A type determines a set of values together with operations and methods specific to those values. A type may be denoted by a type name, if it has one, or specified using a type literal, which composes a type from existing types.\nType = TypeName | TypeLit | \u0026quot;(\u0026quot; Type \u0026quot;)\u0026quot; . TypeName = identifier | QualifiedIdent . TypeLit = ArrayType | StructType | PointerType | FunctionType | InterfaceType | SliceType | MapType | ChannelType . The language predeclares certain type names. Others are introduced with type declarations. Composite types—array, struct, pointer, function, interface, slice, map, and channel types—may be constructed using type literals.\nEach type T has an underlying type: If T is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is T itself. Otherwise, T's underlying type is the underlying type of the type to which T refers in its type declaration.\ntype ( A1 = string A2 = A1 ) type ( B1 string B2 B1 B3 []B1 B4 B3 ) The underlying type of string, A1, A2, B1, and B2 is string. The underlying type of []B1, B3, and B4 is []B1.\nMethod sets A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T). Further rules apply to structs containing embedded fields, as described in the section on struct types. Any other type has an empty method set. In a method set, each method must have a unique non-blank method name.\nThe method set of a type determines the interfaces that the type implements and the methods that can be called using a receiver of that type.\nBoolean types A boolean type represents the set of Boolean truth values denoted by the predeclared constants true and false. The predeclared boolean type is bool; it is a defined type.\nNumeric types A numeric type represents sets of integer or floating-point values. The predeclared architecture-independent numeric types are:\nuint8 the set of all unsigned 8-bit integers (0 to 255) uint16 the set of all unsigned 16-bit integers (0 to 65535) uint32 the set of all unsigned 32-bit integers (0 to 4294967295) uint64 the set of all unsigned 64-bit integers (0 to 18446744073709551615) int8 the set of all signed 8-bit integers (-128 to 127) int16 the set of all signed 16-bit integers (-32768 to 32767) int32 the set of all signed 32-bit integers (-2147483648 to 2147483647) int64 the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807) float32 the set of all IEEE-754 32-bit floating-point numbers float64 the set of all IEEE-754 64-bit floating-point numbers complex64 the set of all complex numbers with float32 real and imaginary parts complex128 the set of all complex numbers with float64 real and imaginary parts byte alias for uint8 rune alias for int32 The value of an n-bit integer is n bits wide and represented using two\u0026rsquo;s complement arithmetic.\nThere is also a set of predeclared numeric types with implementation-specific sizes:\nuint either 32 or 64 bits int same size as uint uintptr an unsigned integer large enough to store the uninterpreted bits of a pointer value To avoid portability issues all numeric types are defined types and thus distinct except byte, which is an alias for uint8, and rune, which is an alias for int32. Explicit conversions are required when different numeric types are mixed in an expression or assignment. For instance, int32 and int are not the same type even though they may have the same size on a particular architecture.\nString types A string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. The number of bytes is called the length of the string and is never negative. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type is string; it is a defined type.\nThe length of a string s can be discovered using the built-in function len. The length is a compile-time constant if the string is a constant. A string\u0026rsquo;s bytes can be accessed by integer indices 0 through len(s)-1. It is illegal to take the address of such an element; if s[i] is the i'th byte of a string, \u0026amp;s[i] is invalid.\nArray types An array is a numbered sequence of elements of a single type, called the element type. The number of elements is called the length of the array and is never negative.\nArrayType = \u0026quot;[\u0026quot; ArrayLength \u0026quot;]\u0026quot; ElementType . ArrayLength = Expression . ElementType = Type . The length is part of the array\u0026rsquo;s type; it must evaluate to a non-negative constant representable by a value of type int. The length of array a can be discovered using the built-in function len. The elements can be addressed by integer indices 0 through len(a)-1. Array types are always one-dimensional but may be composed to form multi-dimensional types.\n[32]byte [2*N] struct { x, y int32 } [1000]*float64 [3][5]int [2][2][2]float64 // same as [2]([2]([2]float64)) Slice types A slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The number of elements is called the length of the slice and is never negative. The value of an uninitialized slice is nil.\nSliceType = \u0026quot;[\u0026quot; \u0026quot;]\u0026quot; ElementType . The length of a slice s can be discovered by the built-in function len; unlike with arrays it may change during execution. The elements can be addressed by integer indices 0 through len(s)-1. The slice index of a given element may be less than the index of the same element in the underlying array.\nA slice, once initialized, is always associated with an underlying array that holds its elements. A slice therefore shares storage with its array and with other slices of the same array; by contrast, distinct arrays always represent distinct storage.\nThe array underlying a slice may extend past the end of the slice. The capacity is a measure of that extent: it is the sum of the length of the slice and the length of the array beyond the slice; a slice of length up to that capacity can be created by slicing a new one from the original slice. The capacity of a slice a can be discovered using the built-in function cap(a).\nA new, initialized slice value for a given element type T is made using the built-in function make, which takes a slice type and parameters specifying the length and optionally the capacity. A slice created with make always allocates a new, hidden array to which the returned slice value refers. That is, executing\nmake([]T, length, capacity) produces the same slice as allocating an array and slicing it, so these two expressions are equivalent:\nmake([]int, 50, 100) new([100]int)[0:50] Like arrays, slices are always one-dimensional but may be composed to construct higher-dimensional objects. With arrays of arrays, the inner arrays are, by construction, always the same length; however with slices of slices (or arrays of slices), the inner lengths may vary dynamically. Moreover, the inner slices must be initialized individually.\nStruct types A struct is a sequence of named elements, called fields, each of which has a name and a type. Field names may be specified explicitly (IdentifierList) or implicitly (EmbeddedField). Within a struct, non-blank field names must be unique.\nStructType = \u0026quot;struct\u0026quot; \u0026quot;{\u0026quot; { FieldDecl \u0026quot;;\u0026quot; } \u0026quot;}\u0026quot; . FieldDecl = (IdentifierList Type | EmbeddedField) [ Tag ] . EmbeddedField = [ \u0026quot;*\u0026quot; ] TypeName . Tag = string_lit . // An empty struct. struct {} // A struct with 6 fields. struct { x, y int u float32 _ float32 // padding A *[]int F func() } A field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type. The unqualified type name acts as the field name.\n// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4 struct { T1 // field name is T1 *T2 // field name is T2 P.T3 // field name is T3 *P.T4 // field name is T4 x, y int // field names are x and y } The following declaration is illegal because field names must be unique in a struct type:\nstruct { T // conflicts with embedded field *T and *P.T *T // conflicts with embedded field T and *P.T *P.T // conflicts with embedded field T and *T } A field or method f of an embedded field in a struct x is called promoted if x.f is a legal selector that denotes that field or method f.\nPromoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.\nGiven a struct type S and a defined type T, promoted methods are included in the method set of the struct as follows:\n If S contains an embedded field T, the method sets of S and *S both include promoted methods with receiver T. The method set of *S also includes promoted methods with receiver *T. If S contains an embedded field *T, the method sets of S and *S both include promoted methods with receiver T or *T.  A field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored.\nstruct { x, y float64 \u0026quot;\u0026quot; // an empty tag string is like an absent tag name string \u0026quot;any string is permitted as a tag\u0026quot; _ [4]byte \u0026quot;ceci n'est pas un champ de structure\u0026quot; } // A struct corresponding to a TimeStamp protocol buffer. // The tag strings define the protocol buffer field numbers; // they follow the convention outlined by the reflect package. struct { microsec uint64 `protobuf:\u0026quot;1\u0026quot;` serverIP6 uint64 `protobuf:\u0026quot;2\u0026quot;` } Pointer types A pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. The value of an uninitialized pointer is nil.\nPointerType = \u0026quot;*\u0026quot; BaseType . BaseType = Type . *Point *[4]int Function types A function type denotes the set of all functions with the same parameter and result types. The value of an uninitialized variable of function type is nil.\nFunctionType = \u0026quot;func\u0026quot; Signature . Signature = Parameters [ Result ] . Result = Parameters | Type . Parameters = \u0026quot;(\u0026quot; [ ParameterList [ \u0026quot;,\u0026quot; ] ] \u0026quot;)\u0026quot; . ParameterList = ParameterDecl { \u0026quot;,\u0026quot; ParameterDecl } . ParameterDecl = [ IdentifierList ] [ \u0026quot;...\u0026quot; ] Type . Within a list of parameters or results, the names (IdentifierList) must either all be present or all be absent. If present, each name stands for one item (parameter or result) of the specified type and all non-blank names in the signature must be unique. If absent, each type stands for one item of that type. Parameter and result lists are always parenthesized except that if there is exactly one unnamed result it may be written as an unparenthesized type.\nThe final incoming parameter in a function signature may have a type prefixed with .... A function with such a parameter is called variadic and may be invoked with zero or more arguments for that parameter.\nfunc() func(x int) int func(a, _ int, z float32) bool func(a, b int, z float32) (bool) func(prefix string, values ...int) func(a, b int, z float64, opt ...interface{}) (success bool) func(int, int, float64) (float64, *[]int) func(n int) func(p *T) Interface types An interface type specifies a method set called its interface. A variable of interface type can store a value of any type with a method set that is any superset of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.\nInterfaceType = \u0026quot;interface\u0026quot; \u0026quot;{\u0026quot; { ( MethodSpec | InterfaceTypeName ) \u0026quot;;\u0026quot; } \u0026quot;}\u0026quot; . MethodSpec = MethodName Signature . MethodName = identifier . InterfaceTypeName = TypeName . An interface type may specify methods explicitly through method specifications, or it may embed methods of other interfaces through interface type names.\n// A simple File interface. interface { Read([]byte) (int, error) Write([]byte) (int, error) Close() error } The name of each explicitly specified method must be unique and not blank.\ninterface { String() string String() string // illegal: String not unique _(x int) // illegal: method must have non-blank name } More than one type may implement an interface. For instance, if two types S1 and S2 have the method set\nfunc (p T) Read(p []byte) (n int, err error) func (p T) Write(p []byte) (n int, err error) func (p T) Close() error (where T stands for either S1 or S2) then the File interface is implemented by both S1 and S2, regardless of what other methods S1 and S2 may have or share.\nA type implements any interface comprising any subset of its methods and may therefore implement several distinct interfaces. For instance, all types implement the empty interface:\ninterface{} Similarly, consider this interface specification, which appears within a type declaration to define an interface called Locker:\ntype Locker interface { Lock() Unlock() } If S1 and S2 also implement\nfunc (p T) Lock() { … } func (p T) Unlock() { … } they implement the Locker interface as well as the File interface.\nAn interface T may use a (possibly qualified) interface type name E in place of a method specification. This is called embedding interface E in T. The method set of T is the union of the method sets of T’s explicitly declared methods and of T’s embedded interfaces.\ntype Reader interface { Read(p []byte) (n int, err error) Close() error } type Writer interface { Write(p []byte) (n int, err error) Close() error } // ReadWriter's methods are Read, Write, and Close. type ReadWriter interface { Reader // includes methods of Reader in ReadWriter's method set Writer // includes methods of Writer in ReadWriter's method set } A union of method sets contains the (exported and non-exported) methods of each method set exactly once, and methods with the same names must have identical signatures.\ntype ReadCloser interface { Reader // includes methods of Reader in ReadCloser's method set Close() // illegal: signatures of Reader.Close and Close are different } An interface type T may not embed itself or any interface type that embeds T, recursively.\n// illegal: Bad cannot embed itself type Bad interface { Bad } // illegal: Bad1 cannot embed itself using Bad2 type Bad1 interface { Bad2 } type Bad2 interface { Bad1 } Map types A map is an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type. The value of an uninitialized map is nil.\nMapType = \u0026quot;map\u0026quot; \u0026quot;[\u0026quot; KeyType \u0026quot;]\u0026quot; ElementType . KeyType = Type . The comparison operators == and != must be fully defined for operands of the key type; thus the key type must not be a function, map, or slice. If the key type is an interface type, these comparison operators must be defined for the dynamic key values; failure will cause a run-time panic.\nmap[string]int map[*T]struct{ x, y float64 } map[string]interface{} The number of map elements is called its length. For a map m, it can be discovered using the built-in function len and may change during execution. Elements may be added during execution using assignments and retrieved with index expressions; they may be removed with the delete built-in function.\nA new, empty map value is made using the built-in function make, which takes the map type and an optional capacity hint as arguments:\nmake(map[string]int) make(map[string]int, 100) The initial capacity does not bound its size: maps grow to accommodate the number of items stored in them, with the exception of nil maps. A nil map is equivalent to an empty map except that no elements may be added.\nChannel types A channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is nil.\nChannelType = ( \u0026quot;chan\u0026quot; | \u0026quot;chan\u0026quot; \u0026quot;\u0026lt;-\u0026quot; | \u0026quot;\u0026lt;-\u0026quot; \u0026quot;chan\u0026quot; ) ElementType . The optional \u0026lt;- operator specifies the channel direction, send or receive. If no direction is given, the channel is bidirectional. A channel may be constrained only to send or only to receive by assignment or explicit conversion.\nchan T // can be used to send and receive values of type T chan\u0026lt;- float64 // can only be used to send float64s \u0026lt;-chan int // can only be used to receive ints The \u0026lt;- operator associates with the leftmost chan possible:\nchan\u0026lt;- chan int // same as chan\u0026lt;- (chan int) chan\u0026lt;- \u0026lt;-chan int // same as chan\u0026lt;- (\u0026lt;-chan int) \u0026lt;-chan \u0026lt;-chan int // same as \u0026lt;-chan (\u0026lt;-chan int) chan (\u0026lt;-chan int) A new, initialized channel value can be made using the built-in function make, which takes the channel type and an optional capacity as arguments:\nmake(chan int, 100) The capacity, in number of elements, sets the size of the buffer in the channel. If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready. Otherwise, the channel is buffered and communication succeeds without blocking if the buffer is not full (sends) or not empty (receives). A nil channel is never ready for communication.\nA channel may be closed with the built-in function close. The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed.\nA single channel may be used in send statements, receive operations, and calls to the built-in functions cap and len by any number of goroutines without further synchronization. Channels act as first-in-first-out queues. For example, if one goroutine sends values on a channel and a second goroutine receives them, the values are received in the order sent.\nProperties of types and values Type identity Two types are either identical or different.\nA defined type is always different from any other type. Otherwise, two types are identical if their underlying type literals are structurally equivalent; that is, they have the same literal structure and corresponding components have identical types. In detail:\n Two array types are identical if they have identical element types and the same array length. Two slice types are identical if they have identical element types. Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags. Non-exported field names from different packages are always different. Two pointer types are identical if they have identical base types. Two function types are identical if they have the same number of parameters and result values, corresponding parameter and result types are identical, and either both functions are variadic or neither is. Parameter and result names are not required to match. Two interface types are identical if they have the same set of methods with the same names and identical function types. Non-exported method names from different packages are always different. The order of the methods is irrelevant. Two map types are identical if they have identical key and element types. Two channel types are identical if they have identical element types and the same direction.  Given the declarations\ntype ( A0 = []string A1 = A0 A2 = struct{ a, b int } A3 = int A4 = func(A3, float64) *A0 A5 = func(x int, _ float64) *[]string ) type ( B0 A0 B1 []string B2 struct{ a, b int } B3 struct{ a, c int } B4 func(int, float64) *B0 B5 func(x int, y float64) *A1 ) type\tC0 = B0 these types are identical:\nA0, A1, and []string A2 and struct{ a, b int } A3 and int A4, func(int, float64) *[]string, and A5 B0 and C0 []int and []int struct{ a, b *T5 } and struct{ a, b *T5 } func(x int, y float64) *[]string, func(int, float64) (result *[]string), and A5 B0 and B1 are different because they are new types created by distinct type definitions; func(int, float64) *B0 and func(x int, y float64) *[]string are different because B0 is different from []string.\nAssignability A value x is assignable to a variable of type T (\u0026ldquo;x is assignable to T\u0026rdquo;) if one of the following conditions applies:\n x's type is identical to T. x's type V and T have identical underlying types and at least one of V or T is not a defined type. T is an interface type and x implements T. x is a bidirectional channel value, T is a channel type, x's type V and T have identical element types, and at least one of V or T is not a defined type. x is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or interface type. x is an untyped constant representable by a value of type T.  Representability A constant x is representable by a value of type T if one of the following conditions applies:\n x is in the set of values determined by T. T is a floating-point type and x can be rounded to T's precision without overflow. Rounding uses IEEE 754 round-to-even rules but with an IEEE negative zero further simplified to an unsigned zero. Note that constant values never result in an IEEE negative zero, NaN, or infinity. T is a complex type, and x's components real(x) and imag(x) are representable by values of T's component type (float32 or float64).  x T x is representable by a value of T because 'a' byte 97 is in the set of byte values 97 rune rune is an alias for int32, and 97 is in the set of 32-bit integers \u0026quot;foo\u0026quot; string \u0026quot;foo\u0026quot; is in the set of string values 1024 int16 1024 is in the set of 16-bit integers 42.0 byte 42 is in the set of unsigned 8-bit integers 1e10 uint64 10000000000 is in the set of unsigned 64-bit integers 2.718281828459045 float32 2.718281828459045 rounds to 2.7182817 which is in the set of float32 values -1e-1000 float64 -1e-1000 rounds to IEEE -0.0 which is further simplified to 0.0 0i int 0 is an integer value (42 + 0i) float32 42.0 (with zero imaginary part) is in the set of float32 values x T x is not representable by a value of T because 0 bool 0 is not in the set of boolean values 'a' string 'a' is a rune, it is not in the set of string values 1024 byte 1024 is not in the set of unsigned 8-bit integers -1 uint16 -1 is not in the set of unsigned 16-bit integers 1.1 int 1.1 is not an integer value 42i float32 (0 + 42i) is not in the set of float32 values 1e1000 float64 1e1000 overflows to IEEE +Inf after rounding Blocks A block is a possibly empty sequence of declarations and statements within matching brace brackets.\nBlock = \u0026quot;{\u0026quot; StatementList \u0026quot;}\u0026quot; . StatementList = { Statement \u0026quot;;\u0026quot; } . In addition to explicit blocks in the source code, there are implicit blocks:\n The universe block encompasses all Go source text. Each package has a package block containing all Go source text for that package. Each file has a file block containing all Go source text in that file. Each \u0026ldquo;if\u0026rdquo;, \u0026ldquo;for\u0026rdquo;, and \u0026ldquo;switch\u0026rdquo; statement is considered to be in its own implicit block. Each clause in a \u0026ldquo;switch\u0026rdquo; or \u0026ldquo;select\u0026rdquo; statement acts as an implicit block.  Blocks nest and influence scoping.\nDeclarations and scope A declaration binds a non-blank identifier to a constant, type, variable, function, label, or package. Every identifier in a program must be declared. No identifier may be declared twice in the same block, and no identifier may be declared in both the file and package block.\nThe blank identifier may be used like any other identifier in a declaration, but it does not introduce a binding and thus is not declared. In the package block, the identifier init may only be used for init function declarations, and like the blank identifier it does not introduce a new binding.\nDeclaration = ConstDecl | TypeDecl | VarDecl . TopLevelDecl = Declaration | FunctionDecl | MethodDecl . The scope of a declared identifier is the extent of source text in which the identifier denotes the specified constant, type, variable, function, label, or package.\nGo is lexically scoped using blocks:\n The scope of a predeclared identifier is the universe block. The scope of an identifier denoting a constant, type, variable, or function (but not method) declared at top level (outside any function) is the package block. The scope of the package name of an imported package is the file block of the file containing the import declaration. The scope of an identifier denoting a method receiver, function parameter, or result variable is the function body. The scope of a constant or variable identifier declared inside a function begins at the end of the ConstSpec or VarSpec (ShortVarDecl for short variable declarations) and ends at the end of the innermost containing block. The scope of a type identifier declared inside a function begins at the identifier in the TypeSpec and ends at the end of the innermost containing block.  An identifier declared in a block may be redeclared in an inner block. While the identifier of the inner declaration is in scope, it denotes the entity declared by the inner declaration.\nThe package clause is not a declaration; the package name does not appear in any scope. Its purpose is to identify the files belonging to the same package and to specify the default package name for import declarations.\nLabel scopes Labels are declared by labeled statements and are used in the \u0026ldquo;break\u0026rdquo;, \u0026ldquo;continue\u0026rdquo;, and \u0026ldquo;goto\u0026rdquo; statements. It is illegal to define a label that is never used. In contrast to other identifiers, labels are not block scoped and do not conflict with identifiers that are not labels. The scope of a label is the body of the function in which it is declared and excludes the body of any nested function.\nBlank identifier The blank identifier is represented by the underscore character _. It serves as an anonymous placeholder instead of a regular (non-blank) identifier and has special meaning in declarations, as an operand, and in assignments.\nPredeclared identifiers The following identifiers are implicitly declared in the universe block:\nTypes: bool byte complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr Constants: true false iota Zero value: nil Functions: append cap close complex copy delete imag len make new panic print println real recover Exported identifiers An identifier may be exported to permit access to it from another package. An identifier is exported if both:\n the first character of the identifier\u0026rsquo;s name is a Unicode upper case letter (Unicode class \u0026ldquo;Lu\u0026rdquo;); and the identifier is declared in the package block or it is a field name or method name.  All other identifiers are not exported.\nUniqueness of identifiers Given a set of identifiers, an identifier is called unique if it is different from every other in the set. Two identifiers are different if they are spelled differently, or if they appear in different packages and are not exported. Otherwise, they are the same.\nConstant declarations A constant declaration binds a list of identifiers (the names of the constants) to the values of a list of constant expressions. The number of identifiers must be equal to the number of expressions, and the nth identifier on the left is bound to the value of the nth expression on the right.\nConstDecl = \u0026quot;const\u0026quot; ( ConstSpec | \u0026quot;(\u0026quot; { ConstSpec \u0026quot;;\u0026quot; } \u0026quot;)\u0026quot; ) . ConstSpec = IdentifierList [ [ Type ] \u0026quot;=\u0026quot; ExpressionList ] . IdentifierList = identifier { \u0026quot;,\u0026quot; identifier } . ExpressionList = Expression { \u0026quot;,\u0026quot; Expression } . If the type is present, all constants take the type specified, and the expressions must be assignable to that type. If the type is omitted, the constants take the individual types of the corresponding expressions. If the expression values are untyped constants, the declared constants remain untyped and the constant identifiers denote the constant values. For instance, if the expression is a floating-point literal, the constant identifier denotes a floating-point constant, even if the literal\u0026rsquo;s fractional part is zero.\nconst Pi float64 = 3.14159265358979323846 const zero = 0.0 // untyped floating-point constant const ( size int64 = 1024 eof = -1 // untyped integer constant ) const a, b, c = 3, 4, \u0026quot;foo\u0026quot; // a = 3, b = 4, c = \u0026quot;foo\u0026quot;, untyped integer and string constants const u, v float32 = 0, 3 // u = 0.0, v = 3.0 Within a parenthesized const declaration list the expression list may be omitted from any but the first ConstSpec. Such an empty list is equivalent to the textual substitution of the first preceding non-empty expression list and its type if any. Omitting the list of expressions is therefore equivalent to repeating the previous list. The number of identifiers must be equal to the number of expressions in the previous list. Together with the iota constant generator this mechanism permits light-weight declaration of sequential values:\nconst ( Sunday = iota Monday Tuesday Wednesday Thursday Friday Partyday numberOfDays // this constant is not exported ) Iota Within a constant declaration, the predeclared identifier iota represents successive untyped integer constants. Its value is the index of the respective ConstSpec in that constant declaration, starting at zero. It can be used to construct a set of related constants:\nconst ( c0 = iota // c0 == 0 c1 = iota // c1 == 1 c2 = iota // c2 == 2 ) const ( a = 1 \u0026lt;\u0026lt; iota // a == 1 (iota == 0) b = 1 \u0026lt;\u0026lt; iota // b == 2 (iota == 1) c = 3 // c == 3 (iota == 2, unused) d = 1 \u0026lt;\u0026lt; iota // d == 8 (iota == 3) ) const ( u = iota * 42 // u == 0 (untyped integer constant) v float64 = iota * 42 // v == 42.0 (float64 constant) w = iota * 42 // w == 84 (untyped integer constant) ) const x = iota // x == 0 const y = iota // y == 0 By definition, multiple uses of iota in the same ConstSpec all have the same value:\nconst ( bit0, mask0 = 1 \u0026lt;\u0026lt; iota, 1\u0026lt;\u0026lt;iota - 1 // bit0 == 1, mask0 == 0 (iota == 0) bit1, mask1 // bit1 == 2, mask1 == 1 (iota == 1) _, _ // (iota == 2, unused) bit3, mask3 // bit3 == 8, mask3 == 7 (iota == 3) ) This last example exploits the implicit repetition of the last non-empty expression list.\nType declarations A type declaration binds an identifier, the type name, to a type. Type declarations come in two forms: alias declarations and type definitions.\nTypeDecl = \u0026quot;type\u0026quot; ( TypeSpec | \u0026quot;(\u0026quot; { TypeSpec \u0026quot;;\u0026quot; } \u0026quot;)\u0026quot; ) . TypeSpec = AliasDecl | TypeDef . Alias declarations An alias declaration binds an identifier to the given type.\nAliasDecl = identifier \u0026quot;=\u0026quot; Type . Within the scope of the identifier, it serves as an alias for the type.\ntype ( nodeList = []*Node // nodeList and []*Node are identical types Polar = polar // Polar and polar denote identical types ) Type definitions A type definition creates a new, distinct type with the same underlying type and operations as the given type, and binds an identifier to it.\nTypeDef = identifier Type . The new type is called a defined type. It is different from any other type, including the type it is created from.\ntype ( Point struct{ x, y float64 } // Point and struct{ x, y float64 } are different types polar Point // polar and Point denote different types ) type TreeNode struct { left, right *TreeNode value *Comparable } type Block interface { BlockSize() int Encrypt(src, dst []byte) Decrypt(src, dst []byte) } A defined type may have methods associated with it. It does not inherit any methods bound to the given type, but the method set of an interface type or of elements of a composite type remains unchanged:\n// A Mutex is a data type with two methods, Lock and Unlock. type Mutex struct { /* Mutex fields */ } func (m *Mutex) Lock() { /* Lock implementation */ } func (m *Mutex) Unlock() { /* Unlock implementation */ } // NewMutex has the same composition as Mutex but its method set is empty. type NewMutex Mutex // The method set of PtrMutex's underlying type *Mutex remains unchanged, // but the method set of PtrMutex is empty. type PtrMutex *Mutex // The method set of *PrintableMutex contains the methods // Lock and Unlock bound to its embedded field Mutex. type PrintableMutex struct { Mutex } // MyBlock is an interface type that has the same method set as Block. type MyBlock Block Type definitions may be used to define different boolean, numeric, or string types and associate methods with them:\ntype TimeZone int const ( EST TimeZone = -(5 + iota) CST MST PST ) func (tz TimeZone) String() string { return fmt.Sprintf(\u0026quot;GMT%+dh\u0026quot;, tz) } Variable declarations A variable declaration creates one or more variables, binds corresponding identifiers to them, and gives each a type and an initial value.\nVarDecl = \u0026quot;var\u0026quot; ( VarSpec | \u0026quot;(\u0026quot; { VarSpec \u0026quot;;\u0026quot; } \u0026quot;)\u0026quot; ) . VarSpec = IdentifierList ( Type [ \u0026quot;=\u0026quot; ExpressionList ] | \u0026quot;=\u0026quot; ExpressionList ) . var i int var U, V, W float64 var k = 0 var x, y float32 = -1, -2 var ( i int u, v, s = 2.0, 3.0, \u0026quot;bar\u0026quot; ) var re, im = complexSqrt(-1) var _, found = entries[name] // map lookup; only interested in \u0026quot;found\u0026quot; If a list of expressions is given, the variables are initialized with the expressions following the rules for assignments. Otherwise, each variable is initialized to its zero value.\nIf a type is present, each variable is given that type. Otherwise, each variable is given the type of the corresponding initialization value in the assignment. If that value is an untyped constant, it is first implicitly converted to its default type; if it is an untyped boolean value, it is first implicitly converted to type bool. The predeclared value nil cannot be used to initialize a variable with no explicit type.\nvar d = math.Sin(0.5) // d is float64 var i = 42 // i is int var t, ok = x.(T) // t is T, ok is bool var n = nil // illegal Implementation restriction: A compiler may make it illegal to declare a variable inside a function body if the variable is never used.\nShort variable declarations A short variable declaration uses the syntax:\nShortVarDecl = IdentifierList \u0026quot;:=\u0026quot; ExpressionList . It is shorthand for a regular variable declaration with initializer expressions but no types:\n\u0026quot;var\u0026quot; IdentifierList = ExpressionList . i, j := 0, 10 f := func() int { return 7 } ch := make(chan int) r, w, _ := os.Pipe() // os.Pipe() returns a connected pair of Files and an error, if any _, y, _ := coord(p) // coord() returns three values; only interested in y coordinate Unlike regular variable declarations, a short variable declaration may redeclare variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-blank variables is new. As a consequence, redeclaration can only appear in a multi-variable short declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the original.\nfield1, offset := nextField(str, 0) field2, offset := nextField(str, offset) // redeclares offset a, a := 1, 2 // illegal: double declaration of a or no new variable if a was declared elsewhere Short variable declarations may appear only inside functions. In some contexts such as the initializers for \u0026ldquo;if\u0026rdquo;, \u0026ldquo;for\u0026rdquo;, or \u0026ldquo;switch\u0026rdquo; statements, they can be used to declare local temporary variables.\nFunction declarations A function declaration binds an identifier, the function name, to a function.\nFunctionDecl = \u0026quot;func\u0026quot; FunctionName Signature [ FunctionBody ] . FunctionName = identifier . FunctionBody = Block . If the function\u0026rsquo;s signature declares result parameters, the function body\u0026rsquo;s statement list must end in a terminating statement.\nfunc IndexRune(s string, r rune) int { for i, c := range s { if c == r { return i } } // invalid: missing return statement } A function declaration may omit the body. Such a declaration provides the signature for a function implemented outside Go, such as an assembly routine.\nfunc min(x int, y int) int { if x \u0026lt; y { return x } return y } func flushICache(begin, end uintptr) // implemented externally Method declarations A method is a function with a receiver. A method declaration binds an identifier, the method name, to a method, and associates the method with the receiver\u0026rsquo;s base type.\nMethodDecl = \u0026quot;func\u0026quot; Receiver MethodName Signature [ FunctionBody ] . Receiver = Parameters . The receiver is specified via an extra parameter section preceding the method name. That parameter section must declare a single non-variadic parameter, the receiver. Its type must be a defined type T or a pointer to a defined type T. T is called the receiver base type. A receiver base type cannot be a pointer or interface type and it must be defined in the same package as the method. The method is said to be bound to its receiver base type and the method name is visible only within selectors for type T or *T.\nA non-blank receiver identifier must be unique in the method signature. If the receiver\u0026rsquo;s value is not referenced inside the body of the method, its identifier may be omitted in the declaration. The same applies in general to parameters of functions and methods.\nFor a base type, the non-blank names of methods bound to it must be unique. If the base type is a struct type, the non-blank method and field names must be distinct.\nGiven defined type Point, the declarations\nfunc (p *Point) Length() float64 { return math.Sqrt(p.x * p.x + p.y * p.y) } func (p *Point) Scale(factor float64) { p.x *= factor p.y *= factor } bind the methods Length and Scale, with receiver type *Point, to the base type Point.\nThe type of a method is the type of a function with the receiver as first argument. For instance, the method Scale has type\nfunc(p *Point, factor float64) However, a function declared this way is not a method.\nExpressions An expression specifies the computation of a value by applying operators and functions to operands.\nOperands Operands denote the elementary values in an expression. An operand may be a literal, a (possibly qualified) non-blank identifier denoting a constant, variable, or function, or a parenthesized expression.\nThe blank identifier may appear as an operand only on the left-hand side of an assignment.\nOperand = Literal | OperandName | \u0026quot;(\u0026quot; Expression \u0026quot;)\u0026quot; . Literal = BasicLit | CompositeLit | FunctionLit . BasicLit = int_lit | float_lit | imaginary_lit | rune_lit | string_lit . OperandName = identifier | QualifiedIdent . Qualified identifiers A qualified identifier is an identifier qualified with a package name prefix. Both the package name and the identifier must not be blank.\nQualifiedIdent = PackageName \u0026quot;.\u0026quot; identifier . A qualified identifier accesses an identifier in a different package, which must be imported. The identifier must be exported and declared in the package block of that package.\nmath.Sin\t// denotes the Sin function in package math Composite literals Composite literals construct values for structs, arrays, slices, and maps and create a new value each time they are evaluated. They consist of the type of the literal followed by a brace-bound list of elements. Each element may optionally be preceded by a corresponding key.\nCompositeLit = LiteralType LiteralValue . LiteralType = StructType | ArrayType | \u0026quot;[\u0026quot; \u0026quot;...\u0026quot; \u0026quot;]\u0026quot; ElementType | SliceType | MapType | TypeName . LiteralValue = \u0026quot;{\u0026quot; [ ElementList [ \u0026quot;,\u0026quot; ] ] \u0026quot;}\u0026quot; . ElementList = KeyedElement { \u0026quot;,\u0026quot; KeyedElement } . KeyedElement = [ Key \u0026quot;:\u0026quot; ] Element . Key = FieldName | Expression | LiteralValue . FieldName = identifier . Element = Expression | LiteralValue . The LiteralType\u0026rsquo;s underlying type must be a struct, array, slice, or map type (the grammar enforces this constraint except when the type is given as a TypeName). The types of the elements and keys must be assignable to the respective field, element, and key types of the literal type; there is no additional conversion. The key is interpreted as a field name for struct literals, an index for array and slice literals, and a key for map literals. For map literals, all elements must have a key. It is an error to specify multiple elements with the same field name or constant key value. For non-constant map keys, see the section on evaluation order.\nFor struct literals the following rules apply:\n A key must be a field name declared in the struct type. An element list that does not contain any keys must list an element for each struct field in the order in which the fields are declared. If any element has a key, every element must have a key. An element list that contains keys does not need to have an element for each struct field. Omitted fields get the zero value for that field. A literal may omit the element list; such a literal evaluates to the zero value for its type. It is an error to specify an element for a non-exported field of a struct belonging to a different package.  Given the declarations\ntype Point3D struct { x, y, z float64 } type Line struct { p, q Point3D } one may write\norigin := Point3D{} // zero value for Point3D line := Line{origin, Point3D{y: -4, z: 12.3}} // zero value for line.q.x For array and slice literals the following rules apply:\n Each element has an associated integer index marking its position in the array. An element with a key uses the key as its index. The key must be a non-negative constant representable by a value of type int; and if it is typed it must be of integer type. An element without a key uses the previous element\u0026rsquo;s index plus one. If the first element has no key, its index is zero.  Taking the address of a composite literal generates a pointer to a unique variable initialized with the literal\u0026rsquo;s value.\nvar pointer *Point3D = \u0026amp;Point3D{y: 1000} Note that the zero value for a slice or map type is not the same as an initialized but empty value of the same type. Consequently, taking the address of an empty slice or map composite literal does not have the same effect as allocating a new slice or map value with new.\np1 := \u0026amp;[]int{} // p1 points to an initialized, empty slice with value []int{} and length 0 p2 := new([]int) // p2 points to an uninitialized slice with value nil and length 0 The length of an array literal is the length specified in the literal type. If fewer elements than the length are provided in the literal, the missing elements are set to the zero value for the array element type. It is an error to provide elements with index values outside the index range of the array. The notation ... specifies an array length equal to the maximum element index plus one.\nbuffer := [10]string{} // len(buffer) == 10 intSet := [6]int{1, 2, 3, 5} // len(intSet) == 6 days := [...]string{\u0026quot;Sat\u0026quot;, \u0026quot;Sun\u0026quot;} // len(days) == 2 A slice literal describes the entire underlying array literal. Thus the length and capacity of a slice literal are the maximum element index plus one. A slice literal has the form\n[]T{x1, x2, … xn} and is shorthand for a slice operation applied to an array:\ntmp := [n]T{x1, x2, … xn} tmp[0 : n] Within a composite literal of array, slice, or map type T, elements or map keys that are themselves composite literals may elide the respective literal type if it is identical to the element or key type of T. Similarly, elements or keys that are addresses of composite literals may elide the \u0026amp;T when the element or key type is *T.\n[...]Point{{1.5, -3.5}, {0, 0}} // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}} [][]int{{1, 2, 3}, {4, 5}} // same as [][]int{[]int{1, 2, 3}, []int{4, 5}} [][]Point{{{0, 1}, {1, 2}}} // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}} map[string]Point{\u0026quot;orig\u0026quot;: {0, 0}} // same as map[string]Point{\u0026quot;orig\u0026quot;: Point{0, 0}} map[Point]string{{0, 0}: \u0026quot;orig\u0026quot;} // same as map[Point]string{Point{0, 0}: \u0026quot;orig\u0026quot;} type PPoint *Point [2]*Point{{1.5, -3.5}, {}} // same as [2]*Point{\u0026amp;Point{1.5, -3.5}, \u0026amp;Point{}} [2]PPoint{{1.5, -3.5}, {}} // same as [2]PPoint{PPoint(\u0026amp;Point{1.5, -3.5}), PPoint(\u0026amp;Point{})} A parsing ambiguity arises when a composite literal using the TypeName form of the LiteralType appears as an operand between the keyword and the opening brace of the block of an \u0026ldquo;if\u0026rdquo;, \u0026ldquo;for\u0026rdquo;, or \u0026ldquo;switch\u0026rdquo; statement, and the composite literal is not enclosed in parentheses, square brackets, or curly braces. In this rare case, the opening brace of the literal is erroneously parsed as the one introducing the block of statements. To resolve the ambiguity, the composite literal must appear within parentheses.\nif x == (T{a,b,c}[i]) { … } if (x == T{a,b,c}[i]) { … } Examples of valid array, slice, and map literals:\n// list of prime numbers primes := []int{2, 3, 5, 7, 9, 2147483647} // vowels[ch] is true if ch is a vowel vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true} // the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1} filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1} // frequencies in Hz for equal-tempered scale (A4 = 440Hz) noteFrequency := map[string]float32{ \u0026quot;C0\u0026quot;: 16.35, \u0026quot;D0\u0026quot;: 18.35, \u0026quot;E0\u0026quot;: 20.60, \u0026quot;F0\u0026quot;: 21.83, \u0026quot;G0\u0026quot;: 24.50, \u0026quot;A0\u0026quot;: 27.50, \u0026quot;B0\u0026quot;: 30.87, } Function literals A function literal represents an anonymous function.\nFunctionLit = \u0026quot;func\u0026quot; Signature FunctionBody . func(a, b int, z float64) bool { return a*b \u0026lt; int(z) } A function literal can be assigned to a variable or invoked directly.\nf := func(x, y int) int { return x + y } func(ch chan int) { ch \u0026lt;- ACK }(replyChan) Function literals are closures: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.\nPrimary expressions Primary expressions are the operands for unary and binary expressions.\nPrimaryExpr = Operand | Conversion | MethodExpr | PrimaryExpr Selector | PrimaryExpr Index | PrimaryExpr Slice | PrimaryExpr TypeAssertion | PrimaryExpr Arguments . Selector = \u0026quot;.\u0026quot; identifier . Index = \u0026quot;[\u0026quot; Expression \u0026quot;]\u0026quot; . Slice = \u0026quot;[\u0026quot; [ Expression ] \u0026quot;:\u0026quot; [ Expression ] \u0026quot;]\u0026quot; | \u0026quot;[\u0026quot; [ Expression ] \u0026quot;:\u0026quot; Expression \u0026quot;:\u0026quot; Expression \u0026quot;]\u0026quot; . TypeAssertion = \u0026quot;.\u0026quot; \u0026quot;(\u0026quot; Type \u0026quot;)\u0026quot; . Arguments = \u0026quot;(\u0026quot; [ ( ExpressionList | Type [ \u0026quot;,\u0026quot; ExpressionList ] ) [ \u0026quot;...\u0026quot; ] [ \u0026quot;,\u0026quot; ] ] \u0026quot;)\u0026quot; . x 2 (s + \u0026quot;.txt\u0026quot;) f(3.1415, true) Point{1, 2} m[\u0026quot;foo\u0026quot;] s[i : j + 1] obj.color f.p[i].x() Selectors For a primary expression x that is not a package name, the selector expression\nx.f denotes the field or method f of the value x (or sometimes *x; see below). The identifier f is called the (field or method) selector; it must not be the blank identifier. The type of the selector expression is the type of f. If x is a package name, see the section on qualified identifiers.\nA selector f may denote a field or method f of a type T, or it may refer to a field or method f of a nested embedded field of T. The number of embedded fields traversed to reach f is called its depth in T. The depth of a field or method f declared in T is zero. The depth of a field or method f declared in an embedded field A in T is the depth of f in A plus one.\nThe following rules apply to selectors:\n For a value x of type T or *T where T is not a pointer or interface type, x.f denotes the field or method at the shallowest depth in T where there is such an f. If there is not exactly one f with shallowest depth, the selector expression is illegal. For a value x of type I where I is an interface type, x.f denotes the actual method with name f of the dynamic value of x. If there is no method with name f in the method set of I, the selector expression is illegal. As an exception, if the type of x is a defined pointer type and (*x).f is a valid selector expression denoting a field (but not a method), x.f is shorthand for (*x).f. In all other cases, x.f is illegal. If x is of pointer type and has the value nil and x.f denotes a struct field, assigning to or evaluating x.f causes a run-time panic. If x is of interface type and has the value nil, calling or evaluating the method x.f causes a run-time panic.  For example, given the declarations:\ntype T0 struct { x int } func (*T0) M0() type T1 struct { y int } func (T1) M1() type T2 struct { z int T1 *T0 } func (*T2) M2() type Q *T2 var t T2 // with t.T0 != nil var p *T2 // with p != nil and (*p).T0 != nil var q Q = p one may write:\nt.z // t.z t.y // t.T1.y t.x // (*t.T0).x p.z // (*p).z p.y // (*p).T1.y p.x // (*(*p).T0).x q.x // (*(*q).T0).x (*q).x is a valid field selector p.M0() // ((*p).T0).M0() M0 expects *T0 receiver p.M1() // ((*p).T1).M1() M1 expects T1 receiver p.M2() // p.M2() M2 expects *T2 receiver t.M2() // (\u0026amp;t).M2() M2 expects *T2 receiver, see section on Calls but the following is invalid:\nq.M0() // (*q).M0 is valid but not a field selector Method expressions If M is in the method set of type T, T.M is a function that is callable as a regular function with the same arguments as M prefixed by an additional argument that is the receiver of the method.\nMethodExpr = ReceiverType \u0026quot;.\u0026quot; MethodName . ReceiverType = Type . Consider a struct type T with two methods, Mv, whose receiver is of type T, and Mp, whose receiver is of type *T.\ntype T struct { a int } func (tv T) Mv(a int) int { return 0 } // value receiver func (tp *T) Mp(f float32) float32 { return 1 } // pointer receiver var t T The expression\nT.Mv yields a function equivalent to Mv but with an explicit receiver as its first argument; it has signature\nfunc(tv T, a int) int That function may be called normally with an explicit receiver, so these five invocations are equivalent:\nt.Mv(7) T.Mv(t, 7) (T).Mv(t, 7) f1 := T.Mv; f1(t, 7) f2 := (T).Mv; f2(t, 7) Similarly, the expression\n(*T).Mp yields a function value representing Mp with signature\nfunc(tp *T, f float32) float32 For a method with a value receiver, one can derive a function with an explicit pointer receiver, so\n(*T).Mv yields a function value representing Mv with signature\nfunc(tv *T, a int) int Such a function indirects through the receiver to create a value to pass as the receiver to the underlying method; the method does not overwrite the value whose address is passed in the function call.\nThe final case, a value-receiver function for a pointer-receiver method, is illegal because pointer-receiver methods are not in the method set of the value type.\nFunction values derived from methods are called with function call syntax; the receiver is provided as the first argument to the call. That is, given f := T.Mv, f is invoked as f(t, 7) not t.f(7). To construct a function that binds the receiver, use a function literal or method value.\nIt is legal to derive a function value from a method of an interface type. The resulting function takes an explicit receiver of that interface type.\nMethod values If the expression x has static type T and M is in the method set of type T, x.M is called a method value. The method value x.M is a function value that is callable with the same arguments as a method call of x.M. The expression x is evaluated and saved during the evaluation of the method value; the saved copy is then used as the receiver in any calls, which may be executed later.\nThe type T may be an interface or non-interface type.\nAs in the discussion of method expressions above, consider a struct type T with two methods, Mv, whose receiver is of type T, and Mp, whose receiver is of type *T.\ntype T struct { a int } func (tv T) Mv(a int) int { return 0 } // value receiver func (tp *T) Mp(f float32) float32 { return 1 } // pointer receiver var t T var pt *T func makeT() T The expression\nt.Mv yields a function value of type\nfunc(int) int These two invocations are equivalent:\nt.Mv(7) f := t.Mv; f(7) Similarly, the expression\npt.Mp yields a function value of type\nfunc(float32) float32 As with selectors, a reference to a non-interface method with a value receiver using a pointer will automatically dereference that pointer: pt.Mv is equivalent to (*pt).Mv.\nAs with method calls, a reference to a non-interface method with a pointer receiver using an addressable value will automatically take the address of that value: t.Mp is equivalent to (\u0026amp;t).Mp.\nf := t.Mv; f(7) // like t.Mv(7) f := pt.Mp; f(7) // like pt.Mp(7) f := pt.Mv; f(7) // like (*pt).Mv(7) f := t.Mp; f(7) // like (\u0026amp;t).Mp(7) f := makeT().Mp // invalid: result of makeT() is not addressable Although the examples above use non-interface types, it is also legal to create a method value from a value of interface type.\nvar i interface { M(int) } = myVal f := i.M; f(7) // like i.M(7) Index expressions A primary expression of the form\na[x] denotes the element of the array, pointer to array, slice, string or map a indexed by x. The value x is called the index or map key, respectively. The following rules apply:\nIf a is not a map:\n the index x must be of integer type or an untyped constant a constant index must be non-negative and representable by a value of type int a constant index that is untyped is given type int the index x is in range if 0 \u0026lt;= x \u0026lt; len(a), otherwise it is out of range  For a of array type A:\n a constant index must be in range if x is out of range at run time, a run-time panic occurs a[x] is the array element at index x and the type of a[x] is the element type of A  For a of pointer to array type:\n a[x] is shorthand for (*a)[x]  For a of slice type S:\n if x is out of range at run time, a run-time panic occurs a[x] is the slice element at index x and the type of a[x] is the element type of S  For a of string type:\n a constant index must be in range if the string a is also constant if x is out of range at run time, a run-time panic occurs a[x] is the non-constant byte value at index x and the type of a[x] is byte a[x] may not be assigned to  For a of map type M:\n x's type must be assignable to the key type of M if the map contains an entry with key x, a[x] is the map element with key x and the type of a[x] is the element type of M if the map is nil or does not contain such an entry, a[x] is the zero value for the element type of M  Otherwise a[x] is illegal.\nAn index expression on a map a of type map[K]V used in an assignment or initialization of the special form\nv, ok = a[x] v, ok := a[x] var v, ok = a[x] yields an additional untyped boolean value. The value of ok is true if the key x is present in the map, and false otherwise.\nAssigning to an element of a nil map causes a run-time panic.\nSlice expressions Slice expressions construct a substring or slice from a string, array, pointer to array, or slice. There are two variants: a simple form that specifies a low and high bound, and a full form that also specifies a bound on the capacity.\nSimple slice expressions For a string, array, pointer to array, or slice a, the primary expression\na[low : high] constructs a substring or slice. The indices low and high select which elements of operand a appear in the result. The result has indices starting at 0 and length equal to high - low. After slicing the array a\na := [5]int{1, 2, 3, 4, 5} s := a[1:4] the slice s has type []int, length 3, capacity 4, and elements\ns[0] == 2 s[1] == 3 s[2] == 4 For convenience, any of the indices may be omitted. A missing low index defaults to zero; a missing high index defaults to the length of the sliced operand:\na[2:] // same as a[2 : len(a)] a[:3] // same as a[0 : 3] a[:] // same as a[0 : len(a)] If a is a pointer to an array, a[low : high] is shorthand for (*a)[low : high].\nFor arrays or strings, the indices are in range if 0 \u0026lt;= low \u0026lt;= high \u0026lt;= len(a), otherwise they are out of range. For slices, the upper index bound is the slice capacity cap(a) rather than the length. A constant index must be non-negative and representable by a value of type int; for arrays or constant strings, constant indices must also be in range. If both indices are constant, they must satisfy low \u0026lt;= high. If the indices are out of range at run time, a run-time panic occurs.\nExcept for untyped strings, if the sliced operand is a string or slice, the result of the slice operation is a non-constant value of the same type as the operand. For untyped string operands the result is a non-constant value of type string. If the sliced operand is an array, it must be addressable and the result of the slice operation is a slice with the same element type as the array.\nIf the sliced operand of a valid slice expression is a nil slice, the result is a nil slice. Otherwise, if the result is a slice, it shares its underlying array with the operand.\nvar a [10]int s1 := a[3:7] // underlying array of s1 is array a; \u0026amp;s1[2] == \u0026amp;a[5] s2 := s1[1:4] // underlying array of s2 is underlying array of s1 which is array a; \u0026amp;s2[1] == \u0026amp;a[5] s2[1] = 42 // s2[1] == s1[2] == a[5] == 42; they all refer to the same underlying array element Full slice expressions For an array, pointer to array, or slice a (but not a string), the primary expression\na[low : high : max] constructs a slice of the same type, and with the same length and elements as the simple slice expression a[low : high]. Additionally, it controls the resulting slice\u0026rsquo;s capacity by setting it to max - low. Only the first index may be omitted; it defaults to 0. After slicing the array a\na := [5]int{1, 2, 3, 4, 5} t := a[1:3:5] the slice t has type []int, length 2, capacity 4, and elements\nt[0] == 2 t[1] == 3 As for simple slice expressions, if a is a pointer to an array, a[low : high : max] is shorthand for (*a)[low : high : max]. If the sliced operand is an array, it must be addressable.\nThe indices are in range if 0 \u0026lt;= low \u0026lt;= high \u0026lt;= max \u0026lt;= cap(a), otherwise they are out of range. A constant index must be non-negative and representable by a value of type int; for arrays, constant indices must also be in range. If multiple indices are constant, the constants that are present must be in range relative to each other. If the indices are out of range at run time, a run-time panic occurs.\nType assertions For an expression x of interface type and a type T, the primary expression\nx.(T) asserts that x is not nil and that the value stored in x is of type T. The notation x.(T) is called a type assertion.\nMore precisely, if T is not an interface type, x.(T) asserts that the dynamic type of x is identical to the type T. In this case, T must implement the (interface) type of x; otherwise the type assertion is invalid since it is not possible for x to store a value of type T. If T is an interface type, x.(T) asserts that the dynamic type of x implements the interface T.\nIf the type assertion holds, the value of the expression is the value stored in x and its type is T. If the type assertion is false, a run-time panic occurs. In other words, even though the dynamic type of x is known only at run time, the type of x.(T) is known to be T in a correct program.\nvar x interface{} = 7 // x has dynamic type int and value 7 i := x.(int) // i has type int and value 7 type I interface { m() } func f(y I) { s := y.(string) // illegal: string does not implement I (missing method m) r := y.(io.Reader) // r has type io.Reader and the dynamic type of y must implement both I and io.Reader … } A type assertion used in an assignment or initialization of the special form\nv, ok = x.(T) v, ok := x.(T) var v, ok = x.(T) var v, ok T1 = x.(T) yields an additional untyped boolean value. The value of ok is true if the assertion holds. Otherwise it is false and the value of v is the zero value for type T. No run-time panic occurs in this case.\nCalls Given an expression f of function type F,\nf(a1, a2, … an) calls f with arguments a1, a2, … an. Except for one special case, arguments must be single-valued expressions assignable to the parameter types of F and are evaluated before the function is called. The type of the expression is the result type of F. A method invocation is similar but the method itself is specified as a selector upon a value of the receiver type for the method.\nmath.Atan2(x, y) // function call var pt *Point pt.Scale(3.5) // method call with receiver pt In a function call, the function value and arguments are evaluated in the usual order. After they are evaluated, the parameters of the call are passed by value to the function and the called function begins execution. The return parameters of the function are passed by value back to the calling function when the function returns.\nCalling a nil function value causes a run-time panic.\nAs a special case, if the return values of a function or method g are equal in number and individually assignable to the parameters of another function or method f, then the call f(g(*parameters_of_g*)) will invoke f after binding the return values of g to the parameters of f in order. The call of f must contain no parameters other than the call of g, and g must have at least one return value. If f has a final ... parameter, it is assigned the return values of g that remain after assignment of regular parameters.\nfunc Split(s string, pos int) (string, string) { return s[0:pos], s[pos:] } func Join(s, t string) string { return s + t } if Join(Split(value, len(value)/2)) != value { log.Panic(\u0026quot;test fails\u0026quot;) } A method call x.m() is valid if the method set of (the type of) x contains m and the argument list can be assigned to the parameter list of m. If x is addressable and \u0026amp;x's method set contains m, x.m() is shorthand for (\u0026amp;x).m():\nvar p Point p.Scale(3.5) There is no distinct method type and there are no method literals.\nPassing arguments to ... parameters If f is variadic with a final parameter p of type ...T, then within f the type of p is equivalent to type []T. If f is invoked with no actual arguments for p, the value passed to p is nil. Otherwise, the value passed is a new slice of type []T with a new underlying array whose successive elements are the actual arguments, which all must be assignable to T. The length and capacity of the slice is therefore the number of arguments bound to p and may differ for each call site.\nGiven the function and calls\nfunc Greeting(prefix string, who ...string) Greeting(\u0026quot;nobody\u0026quot;) Greeting(\u0026quot;hello:\u0026quot;, \u0026quot;Joe\u0026quot;, \u0026quot;Anna\u0026quot;, \u0026quot;Eileen\u0026quot;) within Greeting, who will have the value nil in the first call, and []string{\u0026quot;Joe\u0026quot;, \u0026quot;Anna\u0026quot;, \u0026quot;Eileen\u0026quot;} in the second.\nIf the final argument is assignable to a slice type []T, it is passed unchanged as the value for a ...T parameter if the argument is followed by .... In this case no new slice is created.\nGiven the slice s and call\ns := []string{\u0026quot;James\u0026quot;, \u0026quot;Jasmine\u0026quot;} Greeting(\u0026quot;goodbye:\u0026quot;, s...) within Greeting, who will have the same value as s with the same underlying array.\nOperators Operators combine operands into expressions.\nExpression = UnaryExpr | Expression binary_op Expression . UnaryExpr = PrimaryExpr | unary_op UnaryExpr . binary_op = \u0026quot;||\u0026quot; | \u0026quot;\u0026amp;\u0026amp;\u0026quot; | rel_op | add_op | mul_op . rel_op = \u0026quot;==\u0026quot; | \u0026quot;!=\u0026quot; | \u0026quot;\u0026lt;\u0026quot; | \u0026quot;\u0026lt;=\u0026quot; | \u0026quot;\u0026gt;\u0026quot; | \u0026quot;\u0026gt;=\u0026quot; . add_op = \u0026quot;+\u0026quot; | \u0026quot;-\u0026quot; | \u0026quot;|\u0026quot; | \u0026quot;^\u0026quot; . mul_op = \u0026quot;*\u0026quot; | \u0026quot;/\u0026quot; | \u0026quot;%\u0026quot; | \u0026quot;\u0026lt;\u0026lt;\u0026quot; | \u0026quot;\u0026gt;\u0026gt;\u0026quot; | \u0026quot;\u0026amp;\u0026quot; | \u0026quot;\u0026amp;^\u0026quot; . unary_op = \u0026quot;+\u0026quot; | \u0026quot;-\u0026quot; | \u0026quot;!\u0026quot; | \u0026quot;^\u0026quot; | \u0026quot;*\u0026quot; | \u0026quot;\u0026amp;\u0026quot; | \u0026quot;\u0026lt;-\u0026quot; . Comparisons are discussed elsewhere. For other binary operators, the operand types must be identical unless the operation involves shifts or untyped constants. For operations involving constants only, see the section on constant expressions.\nExcept for shift operations, if one operand is an untyped constant and the other operand is not, the constant is implicitly converted to the type of the other operand.\nThe right operand in a shift expression must have integer type or be an untyped constant representable by a value of type uint. If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.\nvar s uint = 33 var i = 1\u0026lt;\u0026lt;s // 1 has type int var j int32 = 1\u0026lt;\u0026lt;s // 1 has type int32; j == 0 var k = uint64(1\u0026lt;\u0026lt;s) // 1 has type uint64; k == 1\u0026lt;\u0026lt;33 var m int = 1.0\u0026lt;\u0026lt;s // 1.0 has type int; m == 0 if ints are 32bits in size var n = 1.0\u0026lt;\u0026lt;s == j // 1.0 has type int32; n == true var o = 1\u0026lt;\u0026lt;s == 2\u0026lt;\u0026lt;s // 1 and 2 have type int; o == true if ints are 32bits in size var p = 1\u0026lt;\u0026lt;s == 1\u0026lt;\u0026lt;33 // illegal if ints are 32bits in size: 1 has type int, but 1\u0026lt;\u0026lt;33 overflows int var u = 1.0\u0026lt;\u0026lt;s // illegal: 1.0 has type float64, cannot shift var u1 = 1.0\u0026lt;\u0026lt;s != 0 // illegal: 1.0 has type float64, cannot shift var u2 = 1\u0026lt;\u0026lt;s != 1.0 // illegal: 1 has type float64, cannot shift var v float32 = 1\u0026lt;\u0026lt;s // illegal: 1 has type float32, cannot shift var w int64 = 1.0\u0026lt;\u0026lt;33 // 1.0\u0026lt;\u0026lt;33 is a constant shift expression var x = a[1.0\u0026lt;\u0026lt;s] // 1.0 has type int; x == a[0] if ints are 32bits in size var a = make([]byte, 1.0\u0026lt;\u0026lt;s) // 1.0 has type int; len(a) == 0 if ints are 32bits in size Operator precedence Unary operators have the highest precedence. As the ++ and -- operators form statements, not expressions, they fall outside the operator hierarchy. As a consequence, statement *p++ is the same as (*p)++.\nThere are five precedence levels for binary operators. Multiplication operators bind strongest, followed by addition operators, comparison operators, \u0026amp;\u0026amp; (logical AND), and finally || (logical OR):\nPrecedence Operator 5 * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ 4 + - | ^ 3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 2 \u0026amp;\u0026amp; 1 || Binary operators of the same precedence associate from left to right. For instance, x / y * z is the same as (x / y) * z.\n+x 23 + 3*x[i] x \u0026lt;= f() ^a \u0026gt;\u0026gt; b f() || g() x == y+1 \u0026amp;\u0026amp; \u0026lt;-chanPtr \u0026gt; 0 Arithmetic operators Arithmetic operators apply to numeric values and yield a result of the same type as the first operand. The four standard arithmetic operators (+, -, *, /) apply to integer, floating-point, and complex types; + also applies to strings. The bitwise logical and shift operators apply to integers only.\n+ sum integers, floats, complex values, strings - difference integers, floats, complex values * product integers, floats, complex values / quotient integers, floats, complex values % remainder integers \u0026amp; bitwise AND integers | bitwise OR integers ^ bitwise XOR integers \u0026amp;^ bit clear (AND NOT) integers \u0026lt;\u0026lt; left shift integer \u0026lt;\u0026lt; unsigned integer \u0026gt;\u0026gt; right shift integer \u0026gt;\u0026gt; unsigned integer Integer operators For two integer values x and y, the integer quotient q = x / y and remainder r = x % y satisfy the following relationships:\nx = q*y + r and |r| \u0026lt; |y| with x / y truncated towards zero (\u0026ldquo;truncated division\u0026rdquo;).\n x y x / y x % y 5 3 1 2 -5 3 -1 -2 5 -3 -1 2 -5 -3 1 -2 The one exception to this rule is that if the dividend x is the most negative value for the int type of x, the quotient q = x / -1 is equal to x (and r = 0) due to two\u0026rsquo;s-complement integer overflow:\n\tx, q int8 -128 int16 -32768 int32 -2147483648 int64 -9223372036854775808 If the divisor is a constant, it must not be zero. If the divisor is zero at run time, a run-time panic occurs. If the dividend is non-negative and the divisor is a constant power of 2, the division may be replaced by a right shift, and computing the remainder may be replaced by a bitwise AND operation:\n x x / 4 x % 4 x \u0026gt;\u0026gt; 2 x \u0026amp; 3 11 2 3 2 3 -11 -2 -3 -3 1 The shift operators shift the left operand by the shift count specified by the right operand, which must be non-negative. If the shift count is negative at run time, a run-time panic occurs. The shift operators implement arithmetic shifts if the left operand is a signed integer and logical shifts if it is an unsigned integer. There is no upper limit on the shift count. Shifts behave as if the left operand is shifted n times by 1 for a shift count of n. As a result, x \u0026lt;\u0026lt; 1 is the same as x*2 and x \u0026gt;\u0026gt; 1 is the same as x/2 but truncated towards negative infinity.\nFor integer operands, the unary operators +, -, and ^ are defined as follows:\n+x is 0 + x -x negation is 0 - x ^x bitwise complement is m ^ x with m = \u0026quot;all bits set to 1\u0026quot; for unsigned x and m = -1 for signed x Integer overflow For unsigned integer values, the operations +, -, *, and \u0026lt;\u0026lt; are computed modulo 2n, where n is the bit width of the unsigned integer\u0026rsquo;s type. Loosely speaking, these unsigned integer operations discard high bits upon overflow, and programs may rely on \u0026ldquo;wrap around\u0026rdquo;.\nFor signed integers, the operations +, -, *, /, and \u0026lt;\u0026lt; may legally overflow and the resulting value exists and is deterministically defined by the signed integer representation, the operation, and its operands. Overflow does not cause a run-time panic. A compiler may not optimize code under the assumption that overflow does not occur. For instance, it may not assume that x \u0026lt; x + 1 is always true.\nFloating-point operators For floating-point and complex numbers, +x is the same as x, while -x is the negation of x. The result of a floating-point or complex division by zero is not specified beyond the IEEE-754 standard; whether a run-time panic occurs is implementation-specific.\nAn implementation may combine multiple floating-point operations into a single fused operation, possibly across statements, and produce a result that differs from the value obtained by executing and rounding the instructions individually. An explicit floating-point type conversion rounds to the precision of the target type, preventing fusion that would discard that rounding.\nFor instance, some architectures provide a \u0026ldquo;fused multiply and add\u0026rdquo; (FMA) instruction that computes x*y + z without rounding the intermediate result x*y. These examples show when a Go implementation can use that instruction:\n// FMA allowed for computing r, because x*y is not explicitly rounded: r = x*y + z r = z; r += x*y t = x*y; r = t + z *p = x*y; r = *p + z r = x*y + float64(z) // FMA disallowed for computing r, because it would omit rounding of x*y: r = float64(x*y) + z r = z; r += float64(x*y) t = float64(x*y); r = t + z String concatenation Strings can be concatenated using the + operator or the += assignment operator:\ns := \u0026quot;hi\u0026quot; + string(c) s += \u0026quot; and good bye\u0026quot; String addition creates a new string by concatenating the operands.\nComparison operators Comparison operators compare two operands and yield an untyped boolean value.\n== equal != not equal \u0026lt; less \u0026lt;= less or equal \u0026gt; greater \u0026gt;= greater or equal In any comparison, the first operand must be assignable to the type of the second operand, or vice versa.\nThe equality operators == and != apply to operands that are comparable. The ordering operators \u0026lt;, \u0026lt;=, \u0026gt;, and \u0026gt;= apply to operands that are ordered. These terms and the result of the comparisons are defined as follows:\n Boolean values are comparable. Two boolean values are equal if they are either both true or both false. Integer values are comparable and ordered, in the usual way. Floating-point values are comparable and ordered, as defined by the IEEE-754 standard. Complex values are comparable. Two complex values u and v are equal if both real(u) == real(v) and imag(u) == imag(v). String values are comparable and ordered, lexically byte-wise. Pointer values are comparable. Two pointer values are equal if they point to the same variable or if both have value nil. Pointers to distinct zero-size variables may or may not be equal. Channel values are comparable. Two channel values are equal if they were created by the same call to make or if both have value nil. Interface values are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value nil. A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t's dynamic type is identical to X and t's dynamic value is equal to x. Struct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal. Array values are comparable if values of the array element type are comparable. Two array values are equal if their corresponding elements are equal.  A comparison of two interface values with identical dynamic types causes a run-time panic if values of that type are not comparable. This behavior applies not only to direct interface value comparisons but also when comparing arrays of interface values or structs with interface-valued fields.\nSlice, map, and function values are not comparable. However, as a special case, a slice, map, or function value may be compared to the predeclared identifier nil. Comparison of pointer, channel, and interface values to nil is also allowed and follows from the general rules above.\nconst c = 3 \u0026lt; 4 // c is the untyped boolean constant true type MyBool bool var x, y int var ( // The result of a comparison is an untyped boolean. // The usual assignment rules apply. b3 = x == y // b3 has type bool b4 bool = x == y // b4 has type bool b5 MyBool = x == y // b5 has type MyBool ) Logical operators Logical operators apply to boolean values and yield a result of the same type as the operands. The right operand is evaluated conditionally.\n\u0026amp;\u0026amp; conditional AND p \u0026amp;\u0026amp; q is \u0026quot;if p then q else false\u0026quot; || conditional OR p || q is \u0026quot;if p then true else q\u0026quot; ! NOT !p is \u0026quot;not p\u0026quot; Address operators For an operand x of type T, the address operation \u0026amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, x may also be a (possibly parenthesized) composite literal. If the evaluation of x would cause a run-time panic, then the evaluation of \u0026amp;x does too.\nFor an operand x of pointer type *T, the pointer indirection *x denotes the variable of type T pointed to by x. If x is nil, an attempt to evaluate *x will cause a run-time panic.\n\u0026amp;x \u0026amp;a[f(2)] \u0026amp;Point{2, 3} *p *pf(x) var x *int = nil *x // causes a run-time panic \u0026amp;*x // causes a run-time panic Receive operator For an operand ch of channel type, the value of the receive operation \u0026lt;-ch is the value received from the channel ch. The channel direction must permit receive operations, and the type of the receive operation is the element type of the channel. The expression blocks until a value is available. Receiving from a nil channel blocks forever. A receive operation on a closed channel can always proceed immediately, yielding the element type\u0026rsquo;s zero value after any previously sent values have been received.\nv1 := \u0026lt;-ch v2 = \u0026lt;-ch f(\u0026lt;-ch) \u0026lt;-strobe // wait until clock pulse and discard received value A receive expression used in an assignment or initialization of the special form\nx, ok = \u0026lt;-ch x, ok := \u0026lt;-ch var x, ok = \u0026lt;-ch var x, ok T = \u0026lt;-ch yields an additional untyped boolean result reporting whether the communication succeeded. The value of ok is true if the value received was delivered by a successful send operation to the channel, or false if it is a zero value generated because the channel is closed and empty.\nConversions A conversion changes the type of an expression to the type specified by the conversion. A conversion may appear literally in the source, or it may be implied by the context in which an expression appears.\nAn explicit conversion is an expression of the form T(x) where T is a type and x is an expression that can be converted to type T.\nConversion = Type \u0026quot;(\u0026quot; Expression [ \u0026quot;,\u0026quot; ] \u0026quot;)\u0026quot; . If the type starts with the operator * or \u0026lt;-, or if the type starts with the keyword func and has no result list, it must be parenthesized when necessary to avoid ambiguity:\n*Point(p) // same as *(Point(p)) (*Point)(p) // p is converted to *Point \u0026lt;-chan int(c) // same as \u0026lt;-(chan int(c)) (\u0026lt;-chan int)(c) // c is converted to \u0026lt;-chan int func()(x) // function signature func() x (func())(x) // x is converted to func() (func() int)(x) // x is converted to func() int func() int(x) // x is converted to func() int (unambiguous) A constant value x can be converted to type T if x is representable by a value of T. As a special case, an integer constant x can be explicitly converted to a string type using the same rule as for non-constant x.\nConverting a constant yields a typed constant as result.\nuint(iota) // iota value of type uint float32(2.718281828) // 2.718281828 of type float32 complex128(1) // 1.0 + 0.0i of type complex128 float32(0.49999999) // 0.5 of type float32 float64(-1e-1000) // 0.0 of type float64 string('x') // \u0026quot;x\u0026quot; of type string string(0x266c) // \u0026quot;♬\u0026quot; of type string MyString(\u0026quot;foo\u0026quot; + \u0026quot;bar\u0026quot;) // \u0026quot;foobar\u0026quot; of type MyString string([]byte{'a'}) // not a constant: []byte{'a'} is not a constant (*int)(nil) // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type int(1.2) // illegal: 1.2 cannot be represented as an int string(65.0) // illegal: 65.0 is not an integer constant A non-constant value x can be converted to type T in any of these cases:\n x is assignable to T. ignoring struct tags (see below), x's type and T have identical underlying types. ignoring struct tags (see below), x's type and T are pointer types that are not defined types, and their pointer base types have identical underlying types. x's type and T are both integer or floating point types. x's type and T are both complex types. x is an integer or a slice of bytes or runes and T is a string type. x is a string and T is a slice of bytes or runes.  Struct tags are ignored when comparing struct types for identity for the purpose of conversion:\ntype Person struct { Name string Address *struct { Street string City string } } var data *struct { Name string `json:\u0026quot;name\u0026quot;` Address *struct { Street string `json:\u0026quot;street\u0026quot;` City string `json:\u0026quot;city\u0026quot;` } `json:\u0026quot;address\u0026quot;` } var person = (*Person)(data) // ignoring tags, the underlying types are identical Specific rules apply to (non-constant) conversions between numeric types or to and from a string type. These conversions may change the representation of x and incur a run-time cost. All other conversions only change the type but not the representation of x.\nThere is no linguistic mechanism to convert between pointers and integers. The package unsafe implements this functionality under restricted circumstances.\nConversions between numeric types For the conversion of non-constant numeric values, the following rules apply:\n When converting between integer types, if the value is a signed integer, it is sign extended to implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the result type\u0026rsquo;s size. For example, if v := uint16(0x10F0), then uint32(int8(v)) == 0xFFFFFFF0. The conversion always yields a valid value; there is no indication of overflow. When converting a floating-point number to an integer, the fraction is discarded (truncation towards zero). When converting an integer or floating-point number to a floating-point type, or a complex number to another complex type, the result value is rounded to the precision specified by the destination type. For instance, the value of a variable x of type float32 may be stored using additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the result of rounding x's value to 32-bit precision. Similarly, x + 0.1 may use more than 32 bits of precision, but float32(x + 0.1) does not.  In all non-constant conversions involving floating-point or complex values, if the result type cannot represent the value the conversion succeeds but the result value is implementation-dependent.\nConversions to and from a string type   Converting a signed or unsigned integer value to a string type yields a string containing the UTF-8 representation of the integer. Values outside the range of valid Unicode code points are converted to\n\u0026quot;\\uFFFD\u0026quot; .\nstring('a') // \u0026quot;a\u0026quot; string(-1) // \u0026quot;\\ufffd\u0026quot; == \u0026quot;\\xef\\xbf\\xbd\u0026quot; string(0xf8) // \u0026quot;\\u00f8\u0026quot; == \u0026quot;ø\u0026quot; == \u0026quot;\\xc3\\xb8\u0026quot; type MyString string MyString(0x65e5) // \u0026quot;\\u65e5\u0026quot; == \u0026quot;日\u0026quot; == \u0026quot;\\xe6\\x97\\xa5\u0026quot;   Converting a slice of bytes to a string type yields a string whose successive bytes are the elements of the slice.\nstring([]byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}) // \u0026quot;hellø\u0026quot; string([]byte{}) // \u0026quot;\u0026quot; string([]byte(nil)) // \u0026quot;\u0026quot; type MyBytes []byte string(MyBytes{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}) // \u0026quot;hellø\u0026quot;   Converting a slice of runes to a string type yields a string that is the concatenation of the individual rune values converted to strings.\nstring([]rune{0x767d, 0x9d6c, 0x7fd4}) // \u0026quot;\\u767d\\u9d6c\\u7fd4\u0026quot; == \u0026quot;白鵬翔\u0026quot; string([]rune{}) // \u0026quot;\u0026quot; string([]rune(nil)) // \u0026quot;\u0026quot; type MyRunes []rune string(MyRunes{0x767d, 0x9d6c, 0x7fd4}) // \u0026quot;\\u767d\\u9d6c\\u7fd4\u0026quot; == \u0026quot;白鵬翔\u0026quot;   Converting a value of a string type to a slice of bytes type yields a slice whose successive elements are the bytes of the string.\n[]byte(\u0026quot;hellø\u0026quot;) // []byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'} []byte(\u0026quot;\u0026quot;) // []byte{} MyBytes(\u0026quot;hellø\u0026quot;) // []byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}   Converting a value of a string type to a slice of runes type yields a slice containing the individual Unicode code points of the string.\n[]rune(MyString(\u0026quot;白鵬翔\u0026quot;)) // []rune{0x767d, 0x9d6c, 0x7fd4} []rune(\u0026quot;\u0026quot;) // []rune{} MyRunes(\u0026quot;白鵬翔\u0026quot;) // []rune{0x767d, 0x9d6c, 0x7fd4}   Constant expressions Constant expressions may contain only constant operands and are evaluated at compile time.\nUntyped boolean, numeric, and string constants may be used as operands wherever it is legal to use an operand of boolean, numeric, or string type, respectively.\nA constant comparison always yields an untyped boolean constant. If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.\nAny other operation on untyped constants results in an untyped constant of the same kind; that is, a boolean, integer, floating-point, complex, or string constant. If the untyped operands of a binary operation (other than a shift) are of different kinds, the result is of the operand\u0026rsquo;s kind that appears later in this list: integer, rune, floating-point, complex. For example, an untyped integer constant divided by an untyped complex constant yields an untyped complex constant.\nconst a = 2 + 3.0 // a == 5.0 (untyped floating-point constant) const b = 15 / 4 // b == 3 (untyped integer constant) const c = 15 / 4.0 // c == 3.75 (untyped floating-point constant) const Θ float64 = 3/2 // Θ == 1.0 (type float64, 3/2 is integer division) const Π float64 = 3/2. // Π == 1.5 (type float64, 3/2. is float division) const d = 1 \u0026lt;\u0026lt; 3.0 // d == 8 (untyped integer constant) const e = 1.0 \u0026lt;\u0026lt; 3 // e == 8 (untyped integer constant) const f = int32(1) \u0026lt;\u0026lt; 33 // illegal (constant 8589934592 overflows int32) const g = float64(2) \u0026gt;\u0026gt; 1 // illegal (float64(2) is a typed floating-point constant) const h = \u0026quot;foo\u0026quot; \u0026gt; \u0026quot;bar\u0026quot; // h == true (untyped boolean constant) const j = true // j == true (untyped boolean constant) const k = 'w' + 1 // k == 'x' (untyped rune constant) const l = \u0026quot;hi\u0026quot; // l == \u0026quot;hi\u0026quot; (untyped string constant) const m = string(k) // m == \u0026quot;x\u0026quot; (type string) const Σ = 1 - 0.707i // (untyped complex constant) const Δ = Σ + 2.0e-4 // (untyped complex constant) const Φ = iota*1i - 1/1i // (untyped complex constant) Applying the built-in function complex to untyped integer, rune, or floating-point constants yields an untyped complex constant.\nconst ic = complex(0, c) // ic == 3.75i (untyped complex constant) const iΘ = complex(0, Θ) // iΘ == 1i (type complex128) Constant expressions are always evaluated exactly; intermediate values and the constants themselves may require precision significantly larger than supported by any predeclared type in the language. The following are legal declarations:\nconst Huge = 1 \u0026lt;\u0026lt; 100 // Huge == 1267650600228229401496703205376 (untyped integer constant) const Four int8 = Huge \u0026gt;\u0026gt; 98 // Four == 4 (type int8) The divisor of a constant division or remainder operation must not be zero:\n3.14 / 0.0 // illegal: division by zero The values of typed constants must always be accurately representable by values of the constant type. The following constant expressions are illegal:\nuint(-1) // -1 cannot be represented as a uint int(3.14) // 3.14 cannot be represented as an int int64(Huge) // 1267650600228229401496703205376 cannot be represented as an int64 Four * 300 // operand 300 cannot be represented as an int8 (type of Four) Four * 100 // product 400 cannot be represented as an int8 (type of Four) The mask used by the unary bitwise complement operator ^ matches the rule for non-constants: the mask is all 1s for unsigned constants and -1 for signed and untyped constants.\n^1 // untyped integer constant, equal to -2 uint8(^1) // illegal: same as uint8(-2), -2 cannot be represented as a uint8 ^uint8(1) // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE) int8(^1) // same as int8(-2) ^int8(1) // same as -1 ^ int8(1) = -2 Implementation restriction: A compiler may use rounding while computing untyped floating-point or complex constant expressions; see the implementation restriction in the section on constants. This rounding may cause a floating-point constant expression to be invalid in an integer context, even if it would be integral when calculated using infinite precision, and vice versa.\nOrder of evaluation At package level, initialization dependencies determine the evaluation order of individual initialization expressions in variable declarations. Otherwise, when evaluating the operands of an expression, assignment, or return statement, all function calls, method calls, and communication operations are evaluated in lexical left-to-right order.\nFor example, in the (function-local) assignment\ny[f()], ok = g(h(), i()+x[j()], \u0026lt;-c), k() the function calls and communication happen in the order f(), h(), i(), j(), \u0026lt;-c, g(), and k(). However, the order of those events compared to the evaluation and indexing of x and the evaluation of y is not specified.\na := 1 f := func() int { a++; return a } x := []int{a, f()} // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified m := map[int]int{a: 1, a: 2} // m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified n := map[int]int{a: f()} // n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified At package level, initialization dependencies override the left-to-right rule for individual initialization expressions, but not for operands within each expression:\nvar a, b, c = f() + v(), g(), sqr(u()) + v() func f() int { return c } func g() int { return a } func sqr(x int) int { return x*x } // functions u and v are independent of all other variables and functions The function calls happen in the order u(), sqr(), v(), f(), v(), and g().\nFloating-point operations within a single expression are evaluated according to the associativity of the operators. Explicit parentheses affect the evaluation by overriding the default associativity. In the expression x + (y + z) the addition y + z is performed before adding x.\nStatements Statements control execution.\nStatement = Declaration | LabeledStmt | SimpleStmt | GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt | FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt | DeferStmt . SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl . Terminating statements A terminating statement prevents execution of all statements that lexically appear after it in the same block. The following statements are terminating:\n  A\n\u0026ldquo;return\u0026rdquo;\nor\n\u0026ldquo;goto\u0026rdquo;\nstatement.\n  A call to the built-in function\npanic\n.\n  A\nblock\nin which the statement list ends in a terminating statement.\n  An\n\u0026ldquo;if\u0026rdquo; statement\nin which:\n the \u0026ldquo;else\u0026rdquo; branch is present, and both branches are terminating statements.    A\n\u0026ldquo;for\u0026rdquo; statement\nin which:\n there are no \u0026ldquo;break\u0026rdquo; statements referring to the \u0026ldquo;for\u0026rdquo; statement, and the loop condition is absent.    A\n\u0026ldquo;switch\u0026rdquo; statement\nin which:\n there are no \u0026ldquo;break\u0026rdquo; statements referring to the \u0026ldquo;switch\u0026rdquo; statement, there is a default case, and the statement lists in each case, including the default, end in a terminating statement, or a possibly labeled \u0026ldquo;fallthrough\u0026rdquo; statement.    A\n\u0026ldquo;select\u0026rdquo; statement\nin which:\n there are no \u0026ldquo;break\u0026rdquo; statements referring to the \u0026ldquo;select\u0026rdquo; statement, and the statement lists in each case, including the default if present, end in a terminating statement.    A labeled statement labeling a terminating statement.\n  All other statements are not terminating.\nA statement list ends in a terminating statement if the list is not empty and its final non-empty statement is terminating.\nEmpty statements The empty statement does nothing.\nEmptyStmt = . Labeled statements A labeled statement may be the target of a goto, break or continue statement.\nLabeledStmt = Label \u0026quot;:\u0026quot; Statement . Label = identifier . Error: log.Panic(\u0026quot;error encountered\u0026quot;) Expression statements With the exception of specific built-in functions, function and method calls and receive operations can appear in statement context. Such statements may be parenthesized.\nExpressionStmt = Expression . The following built-in functions are not permitted in statement context:\nappend cap complex imag len make new real unsafe.Alignof unsafe.Offsetof unsafe.Sizeof h(x+y) f.Close() \u0026lt;-ch (\u0026lt;-ch) len(\u0026quot;foo\u0026quot;) // illegal if len is the built-in function Send statements A send statement sends a value on a channel. The channel expression must be of channel type, the channel direction must permit send operations, and the type of the value to be sent must be assignable to the channel\u0026rsquo;s element type.\nSendStmt = Channel \u0026quot;\u0026lt;-\u0026quot; Expression . Channel = Expression . Both the channel and the value expression are evaluated before communication begins. Communication blocks until the send can proceed. A send on an unbuffered channel can proceed if a receiver is ready. A send on a buffered channel can proceed if there is room in the buffer. A send on a closed channel proceeds by causing a run-time panic. A send on a nil channel blocks forever.\nch \u0026lt;- 3 // send value 3 to channel ch IncDec statements The \u0026ldquo;++\u0026rdquo; and \u0026ldquo;\u0026ndash;\u0026rdquo; statements increment or decrement their operands by the untyped constant 1. As with an assignment, the operand must be addressable or a map index expression.\nIncDecStmt = Expression ( \u0026quot;++\u0026quot; | \u0026quot;--\u0026quot; ) . The following assignment statements are semantically equivalent:\nIncDec statement Assignment x++ x += 1 x-- x -= 1 Assignments Assignment = ExpressionList assign_op ExpressionList . assign_op = [ add_op | mul_op ] \u0026quot;=\u0026quot; . Each left-hand side operand must be addressable, a map index expression, or (for = assignments only) the blank identifier. Operands may be parenthesized.\nx = 1 *p = f() a[i] = 23 (k) = \u0026lt;-ch // same as: k = \u0026lt;-ch An assignment operation x op= y where op is a binary arithmetic operator is equivalent to x = x op (y) but evaluates x only once. The op= construct is a single token. In assignment operations, both the left- and right-hand expression lists must contain exactly one single-valued expression, and the left-hand expression must not be the blank identifier.\na[i] \u0026lt;\u0026lt;= 2 i \u0026amp;^= 1\u0026lt;\u0026lt;n A tuple assignment assigns the individual elements of a multi-valued operation to a list of variables. There are two forms. In the first, the right hand operand is a single multi-valued expression such as a function call, a channel or map operation, or a type assertion. The number of operands on the left hand side must match the number of values. For instance, if f is a function returning two values,\nx, y = f() assigns the first value to x and the second to y. In the second form, the number of operands on the left must equal the number of expressions on the right, each of which must be single-valued, and the nth expression on the right is assigned to the nth operand on the left:\none, two, three = '一', '二', '三' The blank identifier provides a way to ignore right-hand side values in an assignment:\n_ = x // evaluate x but ignore it x, _ = f() // evaluate f() but ignore second result value The assignment proceeds in two phases. First, the operands of index expressions and pointer indirections (including implicit pointer indirections in selectors) on the left and the expressions on the right are all evaluated in the usual order. Second, the assignments are carried out in left-to-right order.\na, b = b, a // exchange a and b x := []int{1, 2, 3} i := 0 i, x[i] = 1, 2 // set i = 1, x[0] = 2 i = 0 x[i], i = 2, 1 // set x[0] = 2, i = 1 x[0], x[0] = 1, 2 // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end) x[1], x[3] = 4, 5 // set x[1] = 4, then panic setting x[3] = 5. type Point struct { x, y int } var p *Point x[2], p.x = 6, 7 // set x[2] = 6, then panic setting p.x = 7 i = 2 x = []int{3, 5, 7} for i, x[i] = range x { // set i, x[2] = 0, x[0] break } // after this loop, i == 0 and x == []int{3, 5, 3} In assignments, each value must be assignable to the type of the operand to which it is assigned, with the following special cases:\n Any typed value may be assigned to the blank identifier. If an untyped constant is assigned to a variable of interface type or the blank identifier, the constant is first implicitly converted to its default type. If an untyped boolean value is assigned to a variable of interface type or the blank identifier, it is first implicitly converted to type bool.  If statements \u0026ldquo;If\u0026rdquo; statements specify the conditional execution of two branches according to the value of a boolean expression. If the expression evaluates to true, the \u0026ldquo;if\u0026rdquo; branch is executed, otherwise, if present, the \u0026ldquo;else\u0026rdquo; branch is executed.\nIfStmt = \u0026quot;if\u0026quot; [ SimpleStmt \u0026quot;;\u0026quot; ] Expression Block [ \u0026quot;else\u0026quot; ( IfStmt | Block ) ] . if x \u0026gt; max { x = max } The expression may be preceded by a simple statement, which executes before the expression is evaluated.\nif x := f(); x \u0026lt; y { return x } else if x \u0026gt; z { return z } else { return y } Switch statements \u0026ldquo;Switch\u0026rdquo; statements provide multi-way execution. An expression or type specifier is compared to the \u0026ldquo;cases\u0026rdquo; inside the \u0026ldquo;switch\u0026rdquo; to determine which branch to execute.\nSwitchStmt = ExprSwitchStmt | TypeSwitchStmt . There are two forms: expression switches and type switches. In an expression switch, the cases contain expressions that are compared against the value of the switch expression. In a type switch, the cases contain types that are compared against the type of a specially annotated switch expression. The switch expression is evaluated exactly once in a switch statement.\nExpression switches In an expression switch, the switch expression is evaluated and the case expressions, which need not be constants, are evaluated left-to-right and top-to-bottom; the first one that equals the switch expression triggers execution of the statements of the associated case; the other cases are skipped. If no case matches and there is a \u0026ldquo;default\u0026rdquo; case, its statements are executed. There can be at most one default case and it may appear anywhere in the \u0026ldquo;switch\u0026rdquo; statement. A missing switch expression is equivalent to the boolean value true.\nExprSwitchStmt = \u0026quot;switch\u0026quot; [ SimpleStmt \u0026quot;;\u0026quot; ] [ Expression ] \u0026quot;{\u0026quot; { ExprCaseClause } \u0026quot;}\u0026quot; . ExprCaseClause = ExprSwitchCase \u0026quot;:\u0026quot; StatementList . ExprSwitchCase = \u0026quot;case\u0026quot; ExpressionList | \u0026quot;default\u0026quot; . If the switch expression evaluates to an untyped constant, it is first implicitly converted to its default type; if it is an untyped boolean value, it is first implicitly converted to type bool. The predeclared untyped value nil cannot be used as a switch expression.\nIf a case expression is untyped, it is first implicitly converted to the type of the switch expression. For each (possibly converted) case expression x and the value t of the switch expression, x == t must be a valid comparison.\nIn other words, the switch expression is treated as if it were used to declare and initialize a temporary variable t without explicit type; it is that value of t against which each case expression x is tested for equality.\nIn a case or default clause, the last non-empty statement may be a (possibly labeled) \u0026ldquo;fallthrough\u0026rdquo; statement to indicate that control should flow from the end of this clause to the first statement of the next clause. Otherwise control flows to the end of the \u0026ldquo;switch\u0026rdquo; statement. A \u0026ldquo;fallthrough\u0026rdquo; statement may appear as the last statement of all but the last clause of an expression switch.\nThe switch expression may be preceded by a simple statement, which executes before the expression is evaluated.\nswitch tag { default: s3() case 0, 1, 2, 3: s1() case 4, 5, 6, 7: s2() } switch x := f(); { // missing switch expression means \u0026quot;true\u0026quot; case x \u0026lt; 0: return -x default: return x } switch { case x \u0026lt; y: f1() case x \u0026lt; z: f2() case x == 4: f3() } Implementation restriction: A compiler may disallow multiple case expressions evaluating to the same constant. For instance, the current compilers disallow duplicate integer, floating point, or string constants in case expressions.\nType switches A type switch compares types rather than values. It is otherwise similar to an expression switch. It is marked by a special switch expression that has the form of a type assertion using the reserved word type rather than an actual type:\nswitch x.(type) { // cases } Cases then match actual types T against the dynamic type of the expression x. As with type assertions, x must be of interface type, and each non-interface type T listed in a case must implement the type of x. The types listed in the cases of a type switch must all be different.\nTypeSwitchStmt = \u0026quot;switch\u0026quot; [ SimpleStmt \u0026quot;;\u0026quot; ] TypeSwitchGuard \u0026quot;{\u0026quot; { TypeCaseClause } \u0026quot;}\u0026quot; . TypeSwitchGuard = [ identifier \u0026quot;:=\u0026quot; ] PrimaryExpr \u0026quot;.\u0026quot; \u0026quot;(\u0026quot; \u0026quot;type\u0026quot; \u0026quot;)\u0026quot; . TypeCaseClause = TypeSwitchCase \u0026quot;:\u0026quot; StatementList . TypeSwitchCase = \u0026quot;case\u0026quot; TypeList | \u0026quot;default\u0026quot; . TypeList = Type { \u0026quot;,\u0026quot; Type } . The TypeSwitchGuard may include a short variable declaration. When that form is used, the variable is declared at the end of the TypeSwitchCase in the implicit block of each clause. In clauses with a case listing exactly one type, the variable has that type; otherwise, the variable has the type of the expression in the TypeSwitchGuard.\nInstead of a type, a case may use the predeclared identifier nil; that case is selected when the expression in the TypeSwitchGuard is a nil interface value. There may be at most one nil case.\nGiven an expression x of type interface{}, the following type switch:\nswitch i := x.(type) { case nil: printString(\u0026quot;x is nil\u0026quot;) // type of i is type of x (interface{}) case int: printInt(i) // type of i is int case float64: printFloat64(i) // type of i is float64 case func(int) float64: printFunction(i) // type of i is func(int) float64 case bool, string: printString(\u0026quot;type is bool or string\u0026quot;) // type of i is type of x (interface{}) default: printString(\u0026quot;don't know the type\u0026quot;) // type of i is type of x (interface{}) } could be rewritten:\nv := x // x is evaluated exactly once if v == nil { i := v // type of i is type of x (interface{}) printString(\u0026quot;x is nil\u0026quot;) } else if i, isInt := v.(int); isInt { printInt(i) // type of i is int } else if i, isFloat64 := v.(float64); isFloat64 { printFloat64(i) // type of i is float64 } else if i, isFunc := v.(func(int) float64); isFunc { printFunction(i) // type of i is func(int) float64 } else { _, isBool := v.(bool) _, isString := v.(string) if isBool || isString { i := v // type of i is type of x (interface{}) printString(\u0026quot;type is bool or string\u0026quot;) } else { i := v // type of i is type of x (interface{}) printString(\u0026quot;don't know the type\u0026quot;) } } The type switch guard may be preceded by a simple statement, which executes before the guard is evaluated.\nThe \u0026ldquo;fallthrough\u0026rdquo; statement is not permitted in a type switch.\nFor statements A \u0026ldquo;for\u0026rdquo; statement specifies repeated execution of a block. There are three forms: The iteration may be controlled by a single condition, a \u0026ldquo;for\u0026rdquo; clause, or a \u0026ldquo;range\u0026rdquo; clause.\nForStmt = \u0026quot;for\u0026quot; [ Condition | ForClause | RangeClause ] Block . Condition = Expression . For statements with single condition In its simplest form, a \u0026ldquo;for\u0026rdquo; statement specifies the repeated execution of a block as long as a boolean condition evaluates to true. The condition is evaluated before each iteration. If the condition is absent, it is equivalent to the boolean value true.\nfor a \u0026lt; b { a *= 2 } For statements with for clause A \u0026ldquo;for\u0026rdquo; statement with a ForClause is also controlled by its condition, but additionally it may specify an init and a post statement, such as an assignment, an increment or decrement statement. The init statement may be a short variable declaration, but the post statement must not. Variables declared by the init statement are re-used in each iteration.\nForClause = [ InitStmt ] \u0026quot;;\u0026quot; [ Condition ] \u0026quot;;\u0026quot; [ PostStmt ] . InitStmt = SimpleStmt . PostStmt = SimpleStmt . for i := 0; i \u0026lt; 10; i++ { f(i) } If non-empty, the init statement is executed once before evaluating the condition for the first iteration; the post statement is executed after each execution of the block (and only if the block was executed). Any element of the ForClause may be empty but the semicolons are required unless there is only a condition. If the condition is absent, it is equivalent to the boolean value true.\nfor cond { S() } is the same as for ; cond ; { S() } for { S() } is the same as for true { S() } For statements with range clause A \u0026ldquo;for\u0026rdquo; statement with a \u0026ldquo;range\u0026rdquo; clause iterates through all entries of an array, slice, string or map, or values received on a channel. For each entry it assigns iteration values to corresponding iteration variables if present and then executes the block.\nRangeClause = [ ExpressionList \u0026quot;=\u0026quot; | IdentifierList \u0026quot;:=\u0026quot; ] \u0026quot;range\u0026quot; Expression . The expression on the right in the \u0026ldquo;range\u0026rdquo; clause is called the range expression, which may be an array, pointer to an array, slice, string, map, or channel permitting receive operations. As with an assignment, if present the operands on the left must be addressable or map index expressions; they denote the iteration variables. If the range expression is a channel, at most one iteration variable is permitted, otherwise there may be up to two. If the last iteration variable is the blank identifier, the range clause is equivalent to the same clause without that identifier.\nThe range expression x is evaluated once before beginning the loop, with one exception: if at most one iteration variable is present and len(x) is constant, the range expression is not evaluated.\nFunction calls on the left are evaluated once per iteration. For each iteration, iteration values are produced as follows if the respective iteration variables are present:\nRange expression 1st value 2nd value array or slice a [n]E, *[n]E, or []E index i int a[i] E string s string type index i int see below rune map m map[K]V key k K m[k] V channel c chan E, \u0026lt;-chan E element e E  For an array, pointer to array, or slice value a, the index iteration values are produced in increasing order, starting at element index 0. If at most one iteration variable is present, the range loop produces iteration values from 0 up to len(a)-1 and does not index into the array or slice itself. For a nil slice, the number of iterations is 0. For a string value, the \u0026ldquo;range\u0026rdquo; clause iterates over the Unicode code points in the string starting at byte index 0. On successive iterations, the index value will be the index of the first byte of successive UTF-8-encoded code points in the string, and the second value, of type rune, will be the value of the corresponding code point. If the iteration encounters an invalid UTF-8 sequence, the second value will be 0xFFFD, the Unicode replacement character, and the next iteration will advance a single byte in the string. The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. If a map entry that has not yet been reached is removed during iteration, the corresponding iteration value will not be produced. If a map entry is created during iteration, that entry may be produced during the iteration or may be skipped. The choice may vary for each entry created and from one iteration to the next. If the map is nil, the number of iterations is 0. For channels, the iteration values produced are the successive values sent on the channel until the channel is closed. If the channel is nil, the range expression blocks forever.  The iteration values are assigned to the respective iteration variables as in an assignment statement.\nThe iteration variables may be declared by the \u0026ldquo;range\u0026rdquo; clause using a form of short variable declaration (:=). In this case their types are set to the types of the respective iteration values and their scope is the block of the \u0026ldquo;for\u0026rdquo; statement; they are re-used in each iteration. If the iteration variables are declared outside the \u0026ldquo;for\u0026rdquo; statement, after execution their values will be those of the last iteration.\nvar testdata *struct { a *[7]int } for i, _ := range testdata.a { // testdata.a is never evaluated; len(testdata.a) is constant // i ranges from 0 to 6 f(i) } var a [10]string for i, s := range a { // type of i is int // type of s is string // s == a[i] g(i, s) } var key string var val interface{} // element type of m is assignable to val m := map[string]int{\u0026quot;mon\u0026quot;:0, \u0026quot;tue\u0026quot;:1, \u0026quot;wed\u0026quot;:2, \u0026quot;thu\u0026quot;:3, \u0026quot;fri\u0026quot;:4, \u0026quot;sat\u0026quot;:5, \u0026quot;sun\u0026quot;:6} for key, val = range m { h(key, val) } // key == last map key encountered in iteration // val == map[key] var ch chan Work = producer() for w := range ch { doWork(w) } // empty a channel for range ch {} Go statements A \u0026ldquo;go\u0026rdquo; statement starts the execution of a function call as an independent concurrent thread of control, or goroutine, within the same address space.\nGoStmt = \u0026quot;go\u0026quot; Expression . The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.\nThe function value and parameters are evaluated as usual in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete. Instead, the function begins executing independently in a new goroutine. When the function terminates, its goroutine also terminates. If the function has any return values, they are discarded when the function completes.\ngo Server() go func(ch chan\u0026lt;- bool) { for { sleep(10); ch \u0026lt;- true }} (c) Select statements A \u0026ldquo;select\u0026rdquo; statement chooses which of a set of possible send or receive operations will proceed. It looks similar to a \u0026ldquo;switch\u0026rdquo; statement but with the cases all referring to communication operations.\nSelectStmt = \u0026quot;select\u0026quot; \u0026quot;{\u0026quot; { CommClause } \u0026quot;}\u0026quot; . CommClause = CommCase \u0026quot;:\u0026quot; StatementList . CommCase = \u0026quot;case\u0026quot; ( SendStmt | RecvStmt ) | \u0026quot;default\u0026quot; . RecvStmt = [ ExpressionList \u0026quot;=\u0026quot; | IdentifierList \u0026quot;:=\u0026quot; ] RecvExpr . RecvExpr = Expression . A case with a RecvStmt may assign the result of a RecvExpr to one or two variables, which may be declared using a short variable declaration. The RecvExpr must be a (possibly parenthesized) receive operation. There can be at most one default case and it may appear anywhere in the list of cases.\nExecution of a \u0026ldquo;select\u0026rdquo; statement proceeds in several steps:\n For all the cases in the statement, the channel operands of receive operations and the channel and right-hand-side expressions of send statements are evaluated exactly once, in source order, upon entering the \u0026ldquo;select\u0026rdquo; statement. The result is a set of channels to receive from or send to, and the corresponding values to send. Any side effects in that evaluation will occur irrespective of which (if any) communication operation is selected to proceed. Expressions on the left-hand side of a RecvStmt with a short variable declaration or assignment are not yet evaluated. If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection. Otherwise, if there is a default case, that case is chosen. If there is no default case, the \u0026ldquo;select\u0026rdquo; statement blocks until at least one of the communications can proceed. Unless the selected case is the default case, the respective communication operation is executed. If the selected case is a RecvStmt with a short variable declaration or an assignment, the left-hand side expressions are evaluated and the received value (or values) are assigned. The statement list of the selected case is executed.  Since communication on nil channels can never proceed, a select with only nil channels and no default case blocks forever.\nvar a []int var c, c1, c2, c3, c4 chan int var i1, i2 int select { case i1 = \u0026lt;-c1: print(\u0026quot;received \u0026quot;, i1, \u0026quot; from c1\\n\u0026quot;) case c2 \u0026lt;- i2: print(\u0026quot;sent \u0026quot;, i2, \u0026quot; to c2\\n\u0026quot;) case i3, ok := (\u0026lt;-c3): // same as: i3, ok := \u0026lt;-c3 if ok { print(\u0026quot;received \u0026quot;, i3, \u0026quot; from c3\\n\u0026quot;) } else { print(\u0026quot;c3 is closed\\n\u0026quot;) } case a[f()] = \u0026lt;-c4: // same as: // case t := \u0026lt;-c4 //\ta[f()] = t default: print(\u0026quot;no communication\\n\u0026quot;) } for { // send random sequence of bits to c select { case c \u0026lt;- 0: // note: no statement, no fallthrough, no folding of cases case c \u0026lt;- 1: } } select {} // block forever Return statements A \u0026ldquo;return\u0026rdquo; statement in a function F terminates the execution of F, and optionally provides one or more result values. Any functions deferred by F are executed before F returns to its caller.\nReturnStmt = \u0026quot;return\u0026quot; [ ExpressionList ] . In a function without a result type, a \u0026ldquo;return\u0026rdquo; statement must not specify any result values.\nfunc noResult() { return } There are three ways to return values from a function with a result type:\n  The return value or values may be explicitly listed in the \u0026ldquo;return\u0026rdquo; statement. Each expression must be single-valued and\nassignable\nto the corresponding element of the function\u0026rsquo;s result type.\nfunc simpleF() int { return 2 } func complexF1() (re float64, im float64) { return -7.0, -4.0 }   The expression list in the \u0026ldquo;return\u0026rdquo; statement may be a single call to a multi-valued function. The effect is as if each value returned from that function were assigned to a temporary variable with the type of the respective value, followed by a \u0026ldquo;return\u0026rdquo; statement listing these variables, at which point the rules of the previous case apply.\nfunc complexF2() (re float64, im float64) { return complexF1() }   The expression list may be empty if the function\u0026rsquo;s result type specifies names for its\nresult parameters\n. The result parameters act as ordinary local variables and the function may assign values to them as necessary. The \u0026ldquo;return\u0026rdquo; statement returns the values of these variables.\nfunc complexF3() (re float64, im float64) { re = 7.0 im = 4.0 return } func (devnull) Write(p []byte) (n int, _ error) { n = len(p) return }   Regardless of how they are declared, all the result values are initialized to the zero values for their type upon entry to the function. A \u0026ldquo;return\u0026rdquo; statement that specifies results sets the result parameters before any deferred functions are executed.\nImplementation restriction: A compiler may disallow an empty expression list in a \u0026ldquo;return\u0026rdquo; statement if a different entity (constant, type, or variable) with the same name as a result parameter is in scope at the place of the return.\nfunc f(n int) (res int, err error) { if _, err := f(n-1); err != nil { return // invalid return statement: err is shadowed } return } Break statements A \u0026ldquo;break\u0026rdquo; statement terminates execution of the innermost \u0026ldquo;for\u0026rdquo;, \u0026ldquo;switch\u0026rdquo;, or \u0026ldquo;select\u0026rdquo; statement within the same function.\nBreakStmt = \u0026quot;break\u0026quot; [ Label ] . If there is a label, it must be that of an enclosing \u0026ldquo;for\u0026rdquo;, \u0026ldquo;switch\u0026rdquo;, or \u0026ldquo;select\u0026rdquo; statement, and that is the one whose execution terminates.\nOuterLoop: for i = 0; i \u0026lt; n; i++ { for j = 0; j \u0026lt; m; j++ { switch a[i][j] { case nil: state = Error break OuterLoop case item: state = Found break OuterLoop } } } Continue statements A \u0026ldquo;continue\u0026rdquo; statement begins the next iteration of the innermost \u0026ldquo;for\u0026rdquo; loop at its post statement. The \u0026ldquo;for\u0026rdquo; loop must be within the same function.\nContinueStmt = \u0026quot;continue\u0026quot; [ Label ] . If there is a label, it must be that of an enclosing \u0026ldquo;for\u0026rdquo; statement, and that is the one whose execution advances.\nRowLoop: for y, row := range rows { for x, data := range row { if data == endOfRow { continue RowLoop } row[x] = data + bias(x, y) } } Goto statements A \u0026ldquo;goto\u0026rdquo; statement transfers control to the statement with the corresponding label within the same function.\nGotoStmt = \u0026quot;goto\u0026quot; Label . goto Error Executing the \u0026ldquo;goto\u0026rdquo; statement must not cause any variables to come into scope that were not already in scope at the point of the goto. For instance, this example:\n\tgoto L // BAD v := 3 L: is erroneous because the jump to label L skips the creation of v.\nA \u0026ldquo;goto\u0026rdquo; statement outside a block cannot jump to a label inside that block. For instance, this example:\nif n%2 == 1 { goto L1 } for n \u0026gt; 0 { f() n-- L1: f() n-- } is erroneous because the label L1 is inside the \u0026ldquo;for\u0026rdquo; statement\u0026rsquo;s block but the goto is not.\nFallthrough statements A \u0026ldquo;fallthrough\u0026rdquo; statement transfers control to the first statement of the next case clause in an expression \u0026ldquo;switch\u0026rdquo; statement. It may be used only as the final non-empty statement in such a clause.\nFallthroughStmt = \u0026quot;fallthrough\u0026quot; . Defer statements A \u0026ldquo;defer\u0026rdquo; statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.\nDeferStmt = \u0026quot;defer\u0026quot; Expression . The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.\nEach time a \u0026ldquo;defer\u0026rdquo; statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. That is, if the surrounding function returns through an explicit return statement, deferred functions are executed after any result parameters are set by that return statement but before the function returns to its caller. If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the \u0026ldquo;defer\u0026rdquo; statement is executed.\nFor instance, if the deferred function is a function literal and the surrounding function has named result parameters that are in scope within the literal, the deferred function may access and modify the result parameters before they are returned. If the deferred function has any return values, they are discarded when the function completes. (See also the section on handling panics.)\nlock(l) defer unlock(l) // unlocking happens before surrounding function returns // prints 3 2 1 0 before surrounding function returns for i := 0; i \u0026lt;= 3; i++ { defer fmt.Print(i) } // f returns 42 func f() (result int) { defer func() { // result is accessed after it was set to 6 by the return statement result *= 7 }() return 6 } Built-in functions Built-in functions are predeclared. They are called like any other function but some of them accept a type instead of an expression as the first argument.\nThe built-in functions do not have standard Go types, so they can only appear in call expressions; they cannot be used as function values.\nClose For a channel c, the built-in function close(c) records that no more values will be sent on the channel. It is an error if c is a receive-only channel. Sending to or closing a closed channel causes a run-time panic. Closing the nil channel also causes a run-time panic. After calling close, and after any previously sent values have been received, receive operations will return the zero value for the channel\u0026rsquo;s type without blocking. The multi-valued receive operation returns a received value along with an indication of whether the channel is closed.\nLength and capacity The built-in functions len and cap take arguments of various types and return a result of type int. The implementation guarantees that the result always fits into an int.\nCall Argument type Result len(s) string type string length in bytes [n]T, *[n]T array length (== n) []T slice length map[K]T map length (number of defined keys) chan T number of elements queued in channel buffer cap(s) [n]T, *[n]T array length (== n) []T slice capacity chan T channel buffer capacity The capacity of a slice is the number of elements for which there is space allocated in the underlying array. At any time the following relationship holds:\n0 \u0026lt;= len(s) \u0026lt;= cap(s) The length of a nil slice, map or channel is 0. The capacity of a nil slice or channel is 0.\nThe expression len(s) is constant if s is a string constant. The expressions len(s) and cap(s) are constants if the type of s is an array or pointer to an array and the expression s does not contain channel receives or (non-constant) function calls; in this case s is not evaluated. Otherwise, invocations of len and cap are not constant and s is evaluated.\nconst ( c1 = imag(2i) // imag(2i) = 2.0 is a constant c2 = len([10]float64{2}) // [10]float64{2} contains no function calls c3 = len([10]float64{c1}) // [10]float64{c1} contains no function calls c4 = len([10]float64{imag(2i)}) // imag(2i) is a constant and no function call is issued c5 = len([10]float64{imag(z)}) // invalid: imag(z) is a (non-constant) function call ) var z complex128 Allocation The built-in function new takes a type T, allocates storage for a variable of that type at run time, and returns a value of type *T pointing to it. The variable is initialized as described in the section on initial values.\nnew(T) For instance\ntype S struct { a int; b float64 } new(S) allocates storage for a variable of type S, initializes it (a=0, b=0.0), and returns a value of type *S containing the address of the location.\nMaking slices, maps and channels The built-in function make takes a type T, which must be a slice, map or channel type, optionally followed by a type-specific list of expressions. It returns a value of type T (not *T). The memory is initialized as described in the section on initial values.\nCall Type T Result make(T, n) slice slice of type T with length n and capacity n make(T, n, m) slice slice of type T with length n and capacity m make(T) map map of type T make(T, n) map map of type T with initial space for approximately n elements make(T) channel unbuffered channel of type T make(T, n) channel buffered channel of type T, buffer size n Each of the size arguments n and m must be of integer type or an untyped constant. A constant size argument must be non-negative and representable by a value of type int; if it is an untyped constant it is given type int. If both n and m are provided and are constant, then n must be no larger than m. If n is negative or larger than m at run time, a run-time panic occurs.\ns := make([]int, 10, 100) // slice with len(s) == 10, cap(s) == 100 s := make([]int, 1e3) // slice with len(s) == cap(s) == 1000 s := make([]int, 1\u0026lt;\u0026lt;63) // illegal: len(s) is not representable by a value of type int s := make([]int, 10, 0) // illegal: len(s) \u0026gt; cap(s) c := make(chan int, 10) // channel with a buffer size of 10 m := make(map[string]int, 100) // map with initial space for approximately 100 elements Calling make with a map type and size hint n will create a map with initial space to hold n map elements. The precise behavior is implementation-dependent.\nAppending to and copying slices The built-in functions append and copy assist in common slice operations. For both functions, the result is independent of whether the memory referenced by the arguments overlaps.\nThe variadic function append appends zero or more values x to s of type S, which must be a slice type, and returns the resulting slice, also of type S. The values x are passed to a parameter of type ...T where T is the element type of S and the respective parameter passing rules apply. As a special case, append also accepts a first argument assignable to type []byte with a second argument of string type followed by .... This form appends the bytes of the string.\nappend(s S, x ...T) S // T is the element type of S If the capacity of s is not large enough to fit the additional values, append allocates a new, sufficiently large underlying array that fits both the existing slice elements and the additional values. Otherwise, append re-uses the underlying array.\ns0 := []int{0, 0} s1 := append(s0, 2) // append a single element s1 == []int{0, 0, 2} s2 := append(s1, 3, 5, 7) // append multiple elements s2 == []int{0, 0, 2, 3, 5, 7} s3 := append(s2, s0...) // append a slice s3 == []int{0, 0, 2, 3, 5, 7, 0, 0} s4 := append(s3[3:6], s3[2:]...) // append overlapping slice s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0} var t []interface{} t = append(t, 42, 3.1415, \u0026quot;foo\u0026quot;) // t == []interface{}{42, 3.1415, \u0026quot;foo\u0026quot;} var b []byte b = append(b, \u0026quot;bar\u0026quot;...) // append string contents b == []byte{'b', 'a', 'r' } The function copy copies slice elements from a source src to a destination dst and returns the number of elements copied. Both arguments must have identical element type T and must be assignable to a slice of type []T. The number of elements copied is the minimum of len(src) and len(dst). As a special case, copy also accepts a destination argument assignable to type []byte with a source argument of a string type. This form copies the bytes from the string into the byte slice.\ncopy(dst, src []T) int copy(dst []byte, src string) int Examples:\nvar a = [...]int{0, 1, 2, 3, 4, 5, 6, 7} var s = make([]int, 6) var b = make([]byte, 5) n1 := copy(s, a[0:]) // n1 == 6, s == []int{0, 1, 2, 3, 4, 5} n2 := copy(s, s[2:]) // n2 == 4, s == []int{2, 3, 4, 5, 4, 5} n3 := copy(b, \u0026quot;Hello, World!\u0026quot;) // n3 == 5, b == []byte(\u0026quot;Hello\u0026quot;) Deletion of map elements The built-in function delete removes the element with key k from a map m. The type of k must be assignable to the key type of m.\ndelete(m, k) // remove element m[k] from map m If the map m is nil or the element m[k] does not exist, delete is a no-op.\nManipulating complex numbers Three functions assemble and disassemble complex numbers. The built-in function complex constructs a complex value from a floating-point real and imaginary part, while real and imag extract the real and imaginary parts of a complex value.\ncomplex(realPart, imaginaryPart floatT) complexT real(complexT) floatT imag(complexT) floatT The type of the arguments and return value correspond. For complex, the two arguments must be of the same floating-point type and the return type is the complex type with the corresponding floating-point constituents: complex64 for float32 arguments, and complex128 for float64 arguments. If one of the arguments evaluates to an untyped constant, it is first implicitly converted to the type of the other argument. If both arguments evaluate to untyped constants, they must be non-complex numbers or their imaginary parts must be zero, and the return value of the function is an untyped complex constant.\nFor real and imag, the argument must be of complex type, and the return type is the corresponding floating-point type: float32 for a complex64 argument, and float64 for a complex128 argument. If the argument evaluates to an untyped constant, it must be a number, and the return value of the function is an untyped floating-point constant.\nThe real and imag functions together form the inverse of complex, so for a value z of a complex type Z, z == Z(complex(real(z), imag(z))).\nIf the operands of these functions are all constants, the return value is a constant.\nvar a = complex(2, -2) // complex128 const b = complex(1.0, -1.4) // untyped complex constant 1 - 1.4i x := float32(math.Cos(math.Pi/2)) // float32 var c64 = complex(5, -x) // complex64 var s int = complex(1, 0) // untyped complex constant 1 + 0i can be converted to int _ = complex(1, 2\u0026lt;\u0026lt;s) // illegal: 2 assumes floating-point type, cannot shift var rl = real(c64) // float32 var im = imag(a) // float64 const c = imag(b) // untyped constant -1.4 _ = imag(3 \u0026lt;\u0026lt; s) // illegal: 3 assumes complex type, cannot shift Handling panics Two built-in functions, panic and recover, assist in reporting and handling run-time panics and program-defined error conditions.\nfunc panic(interface{}) func recover() interface{} While executing a function F, an explicit call to panic or a run-time panic terminates the execution of F. Any functions deferred by F are then executed as usual. Next, any deferred functions run by F's caller are run, and so on up to any deferred by the top-level function in the executing goroutine. At that point, the program is terminated and the error condition is reported, including the value of the argument to panic. This termination sequence is called panicking.\npanic(42) panic(\u0026quot;unreachable\u0026quot;) panic(Error(\u0026quot;cannot parse\u0026quot;)) The recover function allows a program to manage behavior of a panicking goroutine. Suppose a function G defers a function D that calls recover and a panic occurs in a function on the same goroutine in which G is executing. When the running of deferred functions reaches D, the return value of D's call to recover will be the value passed to the call of panic. If D returns normally, without starting a new panic, the panicking sequence stops. In that case, the state of functions called between G and the call to panic is discarded, and normal execution resumes. Any functions deferred by G before D are then run and G's execution terminates by returning to its caller.\nThe return value of recover is nil if any of the following conditions holds:\n panic's argument was nil; the goroutine is not panicking; recover was not called directly by a deferred function.  The protect function in the example below invokes the function argument g and protects callers from run-time panics raised by g.\nfunc protect(g func()) { defer func() { log.Println(\u0026quot;done\u0026quot;) // Println executes normally even if there is a panic if x := recover(); x != nil { log.Printf(\u0026quot;run time panic: %v\u0026quot;, x) } }() log.Println(\u0026quot;start\u0026quot;) g() } Bootstrapping Current implementations provide several built-in functions useful during bootstrapping. These functions are documented for completeness but are not guaranteed to stay in the language. They do not return a result.\nFunction Behavior print prints all arguments; formatting of arguments is implementation-specific println like print but prints spaces between arguments and a newline at the end Implementation restriction: print and println need not accept arbitrary argument types, but printing of boolean, numeric, and string types must be supported.\nPackages Go programs are constructed by linking together packages. A package in turn is constructed from one or more source files that together declare constants, types, variables and functions belonging to the package and which are accessible in all files of the same package. Those elements may be exported and used in another package.\nSource file organization Each source file consists of a package clause defining the package to which it belongs, followed by a possibly empty set of import declarations that declare packages whose contents it wishes to use, followed by a possibly empty set of declarations of functions, types, variables, and constants.\nSourceFile = PackageClause \u0026quot;;\u0026quot; { ImportDecl \u0026quot;;\u0026quot; } { TopLevelDecl \u0026quot;;\u0026quot; } . Package clause A package clause begins each source file and defines the package to which the file belongs.\nPackageClause = \u0026quot;package\u0026quot; PackageName . PackageName = identifier . The PackageName must not be the blank identifier.\npackage math A set of files sharing the same PackageName form the implementation of a package. An implementation may require that all source files for a package inhabit the same directory.\nImport declarations An import declaration states that the source file containing the declaration depends on functionality of the imported package (§Program initialization and execution) and enables access to exported identifiers of that package. The import names an identifier (PackageName) to be used for access and an ImportPath that specifies the package to be imported.\nImportDecl = \u0026quot;import\u0026quot; ( ImportSpec | \u0026quot;(\u0026quot; { ImportSpec \u0026quot;;\u0026quot; } \u0026quot;)\u0026quot; ) . ImportSpec = [ \u0026quot;.\u0026quot; | PackageName ] ImportPath . ImportPath = string_lit . The PackageName is used in qualified identifiers to access exported identifiers of the package within the importing source file. It is declared in the file block. If the PackageName is omitted, it defaults to the identifier specified in the package clause of the imported package. If an explicit period (.) appears instead of a name, all the package\u0026rsquo;s exported identifiers declared in that package\u0026rsquo;s package block will be declared in the importing source file\u0026rsquo;s file block and must be accessed without a qualifier.\nThe interpretation of the ImportPath is implementation-dependent but it is typically a substring of the full file name of the compiled package and may be relative to a repository of installed packages.\nImplementation restriction: A compiler may restrict ImportPaths to non-empty strings using only characters belonging to Unicode\u0026rsquo;s L, M, N, P, and S general categories (the Graphic characters without spaces) and may also exclude the characters !\u0026quot;#$%\u0026amp;'()*,:;\u0026lt;=\u0026gt;?[\\]^{|}` and the Unicode replacement character U+FFFD.\nAssume we have compiled a package containing the package clause package math, which exports function Sin, and installed the compiled package in the file identified by \u0026quot;lib/math\u0026quot;. This table illustrates how Sin is accessed in files that import the package after the various types of import declaration.\nImport declaration Local name of Sin import \u0026quot;lib/math\u0026quot; math.Sin import m \u0026quot;lib/math\u0026quot; m.Sin import . \u0026quot;lib/math\u0026quot; Sin An import declaration declares a dependency relation between the importing and imported package. It is illegal for a package to import itself, directly or indirectly, or to directly import a package without referring to any of its exported identifiers. To import a package solely for its side-effects (initialization), use the blank identifier as explicit package name:\nimport _ \u0026quot;lib/math\u0026quot; An example package Here is a complete Go package that implements a concurrent prime sieve.\npackage main import \u0026quot;fmt\u0026quot; // Send the sequence 2, 3, 4, … to channel 'ch'. func generate(ch chan\u0026lt;- int) { for i := 2; ; i++ { ch \u0026lt;- i // Send 'i' to channel 'ch'. } } // Copy the values from channel 'src' to channel 'dst', // removing those divisible by 'prime'. func filter(src \u0026lt;-chan int, dst chan\u0026lt;- int, prime int) { for i := range src { // Loop over values received from 'src'. if i%prime != 0 { dst \u0026lt;- i // Send 'i' to channel 'dst'. } } } // The prime sieve: Daisy-chain filter processes together. func sieve() { ch := make(chan int) // Create a new channel. go generate(ch) // Start generate() as a subprocess. for { prime := \u0026lt;-ch fmt.Print(prime, \u0026quot;\\n\u0026quot;) ch1 := make(chan int) go filter(ch, ch1, prime) ch = ch1 } } func main() { sieve() } Program initialization and execution The zero value When storage is allocated for a variable, either through a declaration or a call of new, or when a new value is created, either through a composite literal or a call of make, and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the zero value for its type: false for booleans, 0 for numeric types, \u0026quot;\u0026quot; for strings, and nil for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified.\nThese two simple declarations are equivalent:\nvar i int var i int = 0 After\ntype T struct { i int; f float64; next *T } t := new(T) the following holds:\nt.i == 0 t.f == 0.0 t.next == nil The same would also be true after\nvar t T Package initialization Within a package, package-level variable initialization proceeds stepwise, with each step selecting the variable earliest in declaration order which has no dependencies on uninitialized variables.\nMore precisely, a package-level variable is considered ready for initialization if it is not yet initialized and either has no initialization expression or its initialization expression has no dependencies on uninitialized variables. Initialization proceeds by repeatedly initializing the next package-level variable that is earliest in declaration order and ready for initialization, until there are no variables ready for initialization.\nIf any variables are still uninitialized when this process ends, those variables are part of one or more initialization cycles, and the program is not valid.\nMultiple variables on the left-hand side of a variable declaration initialized by single (multi-valued) expression on the right-hand side are initialized together: If any of the variables on the left-hand side is initialized, all those variables are initialized in the same step.\nvar x = a var a, b = f() // a and b are initialized together, before x is initialized For the purpose of package initialization, blank variables are treated like any other variables in declarations.\nThe declaration order of variables declared in multiple files is determined by the order in which the files are presented to the compiler: Variables declared in the first file are declared before any of the variables declared in the second file, and so on.\nDependency analysis does not rely on the actual values of the variables, only on lexical references to them in the source, analyzed transitively. For instance, if a variable x's initialization expression refers to a function whose body refers to variable y then x depends on y. Specifically:\n A reference to a variable or function is an identifier denoting that variable or function. A reference to a method m is a method value or method expression of the form t.m, where the (static) type of t is not an interface type, and the method m is in the method set of t. It is immaterial whether the resulting function value t.m is invoked. A variable, function, or method x depends on a variable y if x's initialization expression or body (for functions and methods) contains a reference to y or to a function or method that depends on y.  For example, given the declarations\nvar ( a = c + b // == 9 b = f() // == 4 c = f() // == 5 d = 3 // == 5 after initialization has finished ) func f() int { d++ return d } the initialization order is d, b, c, a. Note that the order of subexpressions in initialization expressions is irrelevant: a = c + b and a = b + c result in the same initialization order in this example.\nDependency analysis is performed per package; only references referring to variables, functions, and (non-interface) methods declared in the current package are considered. If other, hidden, data dependencies exists between variables, the initialization order between those variables is unspecified.\nFor instance, given the declarations\nvar x = I(T{}).ab() // x has an undetected, hidden dependency on a and b var _ = sideEffect() // unrelated to x, a, or b var a = b var b = 42 type I interface { ab() []int } type T struct{} func (T) ab() []int { return []int{a, b} } the variable a will be initialized after b but whether x is initialized before b, between b and a, or after a, and thus also the moment at which sideEffect() is called (before or after x is initialized) is not specified.\nVariables may also be initialized using functions named init declared in the package block, with no arguments and no result parameters.\nfunc init() { … } Multiple such functions may be defined per package, even within a single source file. In the package block, the init identifier can be used only to declare init functions, yet the identifier itself is not declared. Thus init functions cannot be referred to from anywhere in a program.\nA package with no imports is initialized by assigning initial values to all its package-level variables followed by calling all init functions in the order they appear in the source, possibly in multiple files, as presented to the compiler. If a package has imports, the imported packages are initialized before initializing the package itself. If multiple packages import a package, the imported package will be initialized only once. The importing of packages, by construction, guarantees that there can be no cyclic initialization dependencies.\nPackage initialization—variable initialization and the invocation of init functions—happens in a single goroutine, sequentially, one package at a time. An init function may launch other goroutines, which can run concurrently with the initialization code. However, initialization always sequences the init functions: it will not invoke the next one until the previous one has returned.\nTo ensure reproducible initialization behavior, build systems are encouraged to present multiple files belonging to the same package in lexical file name order to a compiler.\nProgram execution A complete program is created by linking a single, unimported package called the main package with all the packages it imports, transitively. The main package must have package name main and declare a function main that takes no arguments and returns no value.\nfunc main() { … } Program execution begins by initializing the main package and then invoking the function main. When that function invocation returns, the program exits. It does not wait for other (non-main) goroutines to complete.\nErrors The predeclared type error is defined as\ntype error interface { Error() string } It is the conventional interface for representing an error condition, with the nil value representing no error. For instance, a function to read data from a file might be defined:\nfunc Read(f *File, b []byte) (n int, err error) Run-time panics Execution errors such as attempting to index an array out of bounds trigger a run-time panic equivalent to a call of the built-in function panic with a value of the implementation-defined interface type runtime.Error. That type satisfies the predeclared interface type error. The exact error values that represent distinct run-time error conditions are unspecified.\npackage runtime type Error interface { error // and perhaps other methods } System considerations Package unsafe The built-in package unsafe, known to the compiler and accessible through the import path \u0026quot;unsafe\u0026quot;, provides facilities for low-level programming including operations that violate the type system. A package using unsafe must be vetted manually for type safety and may not be portable. The package provides the following interface:\npackage unsafe type ArbitraryType int // shorthand for an arbitrary Go type; it is not a real type type Pointer *ArbitraryType func Alignof(variable ArbitraryType) uintptr func Offsetof(selector ArbitraryType) uintptr func Sizeof(variable ArbitraryType) uintptr A Pointer is a pointer type but a Pointer value may not be dereferenced. Any pointer or value of underlying type uintptr can be converted to a type of underlying type Pointer and vice versa. The effect of converting between Pointer and uintptr is implementation-defined.\nvar f float64 bits = *(*uint64)(unsafe.Pointer(\u0026amp;f)) type ptr unsafe.Pointer bits = *(*uint64)(ptr(\u0026amp;f)) var p ptr = nil The functions Alignof and Sizeof take an expression x of any type and return the alignment or size, respectively, of a hypothetical variable v as if v was declared via var v = x.\nThe function Offsetof takes a (possibly parenthesized) selector s.f, denoting a field f of the struct denoted by s or *s, and returns the field offset in bytes relative to the struct\u0026rsquo;s address. If f is an embedded field, it must be reachable without pointer indirections through fields of the struct. For a struct s with field f:\nuintptr(unsafe.Pointer(\u0026amp;s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(\u0026amp;s.f)) Computer architectures may require memory addresses to be aligned; that is, for addresses of a variable to be a multiple of a factor, the variable\u0026rsquo;s type\u0026rsquo;s alignment. The function Alignof takes an expression denoting a variable of any type and returns the alignment of the (type of the) variable in bytes. For a variable x:\nuintptr(unsafe.Pointer(\u0026amp;x)) % unsafe.Alignof(x) == 0 Calls to Alignof, Offsetof, and Sizeof are compile-time constant expressions of type uintptr.\nSize and alignment guarantees For the numeric types, the following sizes are guaranteed:\ntype size in bytes byte, uint8, int8 1 uint16, int16 2 uint32, int32, float32 4 uint64, int64, float64, complex64 8 complex128 16 The following minimal alignment properties are guaranteed:\n For a variable x of any type: unsafe.Alignof(x) is at least 1. For a variable x of struct type: unsafe.Alignof(x) is the largest of all the values unsafe.Alignof(x.f) for each field f of x, but at least 1. For a variable x of array type: unsafe.Alignof(x) is the same as the alignment of a variable of the array\u0026rsquo;s element type.  A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.\n  Copyright\n   Terms of Service\n   Privacy Policy\n   Report a website issue\n  Supported by Google\n"});index.add({'id':51,'href':'/tags/mysql/','title':"mysql",'content':""});index.add({'id':52,'href':'/categories/mysql/','title':"mysql",'content':""});index.add({'id':53,'href':'/posts/mysql/','title':"Mysql 博客",'content':""});index.add({'id':54,'href':'/posts/mysql1/','title':"Spark",'content':""});index.add({'id':55,'href':'/tags/spark/','title':"spark",'content':""});index.add({'id':56,'href':'/categories/spark/','title':"spark",'content':""});index.add({'id':57,'href':'/tags/imagemagick/','title':"imagemagick",'content':""});index.add({'id':58,'href':'/tags/scala/','title':"scala",'content':""});index.add({'id':59,'href':'/categories/solution/','title':"solution",'content':""});index.add({'id':60,'href':'/docs/example/collapsed/3rd-level/4th-level/','title':"4th Level",'content':"2344th Level of Menu Caesorum illa tu sentit micat vestes papyriferi Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':61,'href':'/docs/example/collapsed/3rd-level/','title':"3rd Level",'content':"3rd Level of Menu Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "});index.add({'id':62,'href':'/docs/example/hidden/','title':"Hidden",'content':"This page is hidden in menu Quondam non pater est dignior ille Eurotas Latent te facies Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "});index.add({'id':63,'href':'/posts/tools/hugo/book/','title':"Book",'content':""});index.add({'id':64,'href':'/posts/tools/hugo/book/buttons/','title':"Buttons 按钮",'content':"按钮是样式链接，可以链接到本地​​页面或外部链接。\nExample {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}回到首页{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;/posts\u0026#34; \u0026gt;}}个人随笔{{\u0026lt; /button \u0026gt;}}  回到首页  个人随笔  "});index.add({'id':65,'href':'/posts/tools/hugo/book/columns/','title':"Columns 分列布局",'content':"Columns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example Left Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  "});index.add({'id':66,'href':'/docs/','title':"Docs",'content':""});index.add({'id':67,'href':'/posts/tools/hugo/book/expand/','title':"Expand 展开和隐藏",'content':"Expand 扩展可以通过隐藏部分文本来帮助减少屏幕混乱。通过单击扩展内容。\n示例 默认 {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}  Expand ↕  Markdown content Lorem markdownum insigne\u0026hellip;    自定义标签 {{\u0026lt; expand \u0026#34;这是自定义标签\u0026#34; \u0026#34;更多\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}  这是自定义标签 更多  Markdown content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   "});index.add({'id':68,'href':'/posts/tools/git/','title':"git 工具",'content':""});index.add({'id':69,'href':'/posts/cheatsheet/data-structure/','title':"Golang cheat-sheet",'content':""});index.add({'id':70,'href':'/posts/cheatsheet/golang/','title':"Golang cheat-sheet",'content':""});index.add({'id':71,'href':'/posts/tools/hugo/book/hints/','title':"Hints 提示",'content':"Hint 提示可用作提示/警告/通知块。 有3种颜色可供选择：info, warning 和 danger。\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa "});index.add({'id':72,'href':'/posts/tools/hugo/book/katex/','title':"KaTex 公式",'content':"KaTeX简码可让您在markdown文档中呈现数学排版。见 KaTeX\nExample {{\u0026lt; katex [display] [class=\u0026#34;text-center\u0026#34;] \u0026gt;}} x = \\begin{cases} a \u0026amp;\\text{if } b \\\\ c \u0026amp;\\text{if } d \\end{cases} {{\u0026lt; /katex \u0026gt;}}     \\( x = \\begin{cases} a \u0026\\text{if } b \\\\ c \u0026\\text{if } d \\end{cases} \\)    Display Mode Example Here is some inline example: \\(\\pi(x)\\)  , rendered in the same line. And below is display example, having display: block \\[ x = \\begin{cases} a \u0026\\text{if } b \\\\ c \u0026\\text{if } d \\end{cases} \\]  Text continues here.\n"});index.add({'id':73,'href':'/posts/tools/hugo/book/mermaid/','title':"Mermaid Chart 图标",'content':"Mermaid 是用于从文本生成svg图表和图表的库。\nExample {{\u0026lt; mermaid [class=\u0026#34;text-center\u0026#34;]\u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}}    sequenceDiagram Alice-Bob: Hello Bob, how are you? alt is sick Bob-Alice: Not so good :( else is well Bob-Alice: Feeling fresh like a daisy end opt Extra response Bob-Alice: Thanks for asking end  "});index.add({'id':74,'href':'/posts/tools/hugo/book/tabs/','title':"Tabs Tab页面",'content':"标签可让您按上下文组织内容，例如，每个受支持平台的安装说明。\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} 示例 MacOS  MacOS This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Linux  Linux This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Windows  Windows This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n "});index.add({'id':75,'href':'/posts/about-me/','title':"关于我",'content':"Fence X 后端研发工程师       邮箱\nyagoodidea@gmail.com  网站\nfencex.github.io  个人技能  Web方向\nGo  PHP  Java  MySQL  Redis  高并发  大数据方向\nScala  Spark  Hive  Ambari  Flink  ...    "});index.add({'id':76,'href':'/posts/cheatsheet/scala/','title':"随笔",'content':""});index.add({'id':77,'href':'/posts/notes/golang/','title':"随笔",'content':""});index.add({'id':78,'href':'/posts/solution/golang/','title':"随笔",'content':""});})();