<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="Redis 数据类型与适用场景"/><meta property="og:title" content="Redis 数据类型与适用场景"/>
<meta property="og:description" content="Redis 数据类型与适用场景"/>
<meta property="og:type" content="article"/>
<meta property="og:url" content="https://keli.tech/posts/redis/redis-data-types/"/>
<meta property="article:published_time" content="2020-03-04T00:00:00+00:00"/>
<meta property="article:modified_time" content="2020-03-04T00:00:00+00:00"/>
<title>Redis 数据类型与适用场景 | FenceX的技术博客</title>
<link rel="icon" href="/favicon.png" type="image/x-icon"/>


<link rel="stylesheet" href="/book.min.edc993575be58655f3e49634e3ca6db09cc38ac9aa03ecdbe81d941636e35273.css" integrity="sha256-7cmTV1vlhlXz5JY048ptsJzDismqA+zb6B2UFjbjUnM="/>


<script defer="" src="/en.search.min.cc774458505997b6f2bec881bc14c5f39800986a167186647a8d5382ea658df8.js" integrity="sha256-zHdEWFBZl7byvsiBvBTF85gAmGoWcYZkeo1Tgupljfg="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
  <link rel="stylesheet" href="/js/audiojs/custom.css"/>
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control"/>
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>FenceX的技术博客</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/"/>
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  <h2 id="提示本博客支持朗读audio-srcspeechmp3-preloadnone">提示:本博客支持朗读<audio src="/audio/f9edff9d177edb293d8d63f08cd6579f.mp3" preload="none"></audio></h2>
<hr/>
<ul>
<li><strong>组件</strong>
<ul>
<li><a href="/posts/redis/">Redis</a></li>
<li><a href="/posts/mysql/">Mysql</a></li>
</ul>
</li>
</ul>
<hr/>
<ul>
<li><strong>备忘</strong>
<ul>
<li><a href="/posts/cheatsheet/golang/">Golang</a></li>
</ul>
</li>
</ul>
<hr/>
<ul>
<li><strong>工具</strong>
<ul>
<li><a href="/posts/tools/git/">Git</a></li>
<li><a href="/docs/shortcodes/buttons/">Buttons</a></li>
<li><a href="/docs/shortcodes/columns/">Columns</a></li>
<li><a href="/docs/shortcodes/expand/">Expand</a></li>
<li><a href="/docs/shortcodes/hints/">Hints</a></li>
<li><a href="/docs/shortcodes/katex/">Katex</a></li>
<li><a href="/docs/shortcodes/mermaid/">Mermaid</a></li>
<li><a href="/docs/shortcodes/tabs/">Tabs</a></li>
</ul>
</li>
</ul>
<hr/>
<ul>
<li><strong>博客工具 – 介绍本博客涉及工具</strong>
<ul>
<li><a href="/posts/tools/hugo/hugo/">Hugo-基本技巧</a></li>
<li><a href="/posts/tools/hugo/hugo-audio/">Hugo-支持audio播放</a></li>
<li><a href="/posts/tools/hugo/hugo-speech/">Hugo-支持博客朗读</a></li>
</ul>
</li>
</ul>
<hr/>
<ul>
<li>
<p><a href="/posts/"><strong>随笔</strong></a></p>
</li>
<li>
<p><a href="/posts/about-me/"><strong>关于我</strong></a></p>
</li>
</ul>
<hr/>








</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu"/>
  </label>

  <strong>Redis 数据类型与适用场景</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents"/>
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control"/>
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#数据类型">数据类型</a>
      <ul>
        <li><a href="#strings">Strings</a></li>
        <li><a href="#lists">Lists</a></li>
        <li><a href="#sets">Sets</a></li>
        <li><a href="#hashes">Hashes</a></li>
        <li><a href="#sorted-sets">Sorted sets</a></li>
        <li><a href="#bitmaps">Bitmaps</a></li>
        <li><a href="#hyperloglogs">HyperLogLogs</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      


<link rel="stylesheet" href=""/>


<article class="markdown">
  <h1>
    <a href="/posts/redis/redis-data-types/">Redis 数据类型与适用场景</a>
  </h1>
  

<div>

  <h5>March 4, 2020</h5>



  
  <div>
    
        <a href="/categories/web/">web</a>, 
        <a href="/categories/redis/">redis</a>
  </div>
  

  
  <div>
    
        <a href="/tags/redis/">redis</a>
  </div>
  


</div>


  <p></p><p>redis 常被拿来与 memcached 来比较，但非常不通的地方就在于 Redis 有非常出色的数据结构，使用非常简便。
本文介绍常用的数据类型和使用场景 Strings Lists Hashes Sets Sorted-Sets 等。</p>
<h1 id="数据类型">数据类型</h1>
<h2 id="strings">Strings</h2>
<p>字符串是Redis值中最基本的一种。
Redis字符串是二进制安全的，这意味着Redis字符串可以包含任何类型的数据，例如JPEG图像或序列化的Ruby对象。</p>
<p>字符串值的最大长度为512 MB。</p>
<p>使用场景：</p>
<ul>
<li>使用INCR系列中的命令将字符串用作原子计数器：INCR，DECR，INCRBY。</li>
<li>使用APPEND命令附加到字符串。</li>
<li>使用字符串作为带有GETRANGE和SETRANGE的随机访问向量。</li>
<li>在很小的空间内编码大量数据，或使用GETBIT和SETBIT创建Redis支持的Bloom Filter。</li>
<li>会话缓存：许多网站利用Redis字符串创建会话缓存，以通过缓存HTML片段或页面来加快其网站体验。由于数据是临时存储在RAM中的，因此此属性使Redis成为会话缓存的理想选择。它能够临时存储特定于用户的数据，例如在线商店中购物车中存储的项目，这一点至关重要，因为您的用户在注销或失去连接时不会丢失其数据。PHP的缓存甚至可以直接在配置文件中指定存储到redis。</li>
</ul>
<h2 id="lists">Lists</h2>
<p>Redis列表只是字符串列表，按插入顺序排序。可以将元素添加到Redis列表中，从而将新元素推到列表的顶部（左侧）或结尾（右侧）。</p>
<p>最大支持 2^32 - 1 个元素， 4294967295 40亿</p>
<p>使用场景：</p>
<ul>
<li>在社交网络中对时间轴建模，请使用LPUSH以便在用户时间轴中添加新元素，并使用LRANGE来检索一些最近插入的项目</li>
<li>可以将LPUSH与LTRIM一起使用，以创建一个列表，该列表从不超过给定数量的元素，而只记住最新的N个元素</li>
<li>列表可以用作消息传递，用作跨系统的数据载体</li>
<li>可以使用列表做更多的事情，此数据类型支持许多命令，包括阻塞命令，例如BLPOP</li>
</ul>
<h2 id="sets">Sets</h2>
<p>Redis集是字符串的无序集合。添加，删除和测试成员的存在 O(1) 复杂度。（恒定时间，与Set中包含的元素数量无关）。<br/>
Redis集具有不允许重复成员的理想属性。多次添加同一元素将导致集合具有该元素的单个副本。实际上，这意味着添加成员不需要检查是否存在，然后进行添加操作。<br/>
可以在很短的时间内完成集的相交，交集，差集。</p>
<p>最大支持 2^32 - 1 个元素， 4294967295 40亿</p>
<p>使用场景：</p>
<ul>
<li>使用Redis集来跟踪独特的事物， 比如UV，根据IP去重。想知道访问给定博客帖子的所有唯一IP地址吗？每次处理页面视图时，只需使用SADD。您确定不会插入重复的IP。</li>
<li>Redis Set 很好地表示关系。您可以使用Set代表每个标签，使用Redis创建标签系统。然后，可以使用SADD命令将具有给定标签的所有对象的所有ID添加到代表该特定标签的Set中。您是否希望所有对象的所有ID同时具有三个不同的标签？只需使用SINTER。</li>
<li>您可以使用 Set 使用 SPOP 或 SRANDMEMBER 命令随机提取元素。</li>
</ul>
<h2 id="hashes">Hashes</h2>
<p>Redis Hashes 是字符串字段和字符串值之间的映射，因此它们是表示对象的理想数据类型（例如，具有多个字段（例如名称，姓氏，年龄等）的User）：</p>
<pre><code>@cli
HMSET user:1000 username antirez password P1pp0 age 34
HGETALL user:1000
HSET user:1000 password 12345
HGETALL user:1000
</code></pre>
<p>具有几个字段（官方建议大概最多一百个左右）的散列以占用很少空间的方式存储，因此您可以在小型Redis实例中存储数百万个对象。<br/>
尽管哈希主要用于表示对象，但是它们能够存储许多元素，因此您也可以将哈希用于许多其他任务。<br/>
每个哈希最多可以存储2 ^ 32-1个字段-值对（超过40亿个）</p>
<p>使用场景：</p>
<ul>
<li>缓存用户信息</li>
<li>可以相似的多个 String 用 Hashes 汇集在一起</li>
</ul>
<h2 id="sorted-sets">Sorted sets</h2>
<p>与Redis集类似，Redis排序集是非重复的String集合。区别在于，排序集的每个成员都与Score相关联，该得分用于从最小到最大得分中获取排序的排序集。虽然成员是唯一的，但分数可能会重复。</p>
<p>使用排序集，您可以非常快速地添加 O(log(N))，删除 O(M*log(N)) 或更新元素（时间与元素数量的对数成正比）。<br/>
由于元素是按顺序排序的，因此可以非常快速地按分数或按排名（位置）获得范围。<br/>
访问排序集的中间位置也非常快，因此您可以将排序集用作非重复元素的智能列表，<br/>
从中可以快速访问所需的所有内容：元素的顺序，快速检测元素是否存在，对中间元素的快速访问。</p>
<p>简而言之，使用Sorted Sets，可以执行许多性能出色的任务，而这些任务实际上很难在其他类型的数据库中建模。<br/>
比如：</p>
<ul>
<li>
<p>积分排行版，使用 ZADD 来更新元素的分值， ZRANGE 来获取范围分值的数据，ZRANK 查找排行，时间复杂度都是 O(log(N)+M) ,速度很快</p>
</li>
<li>
<p>Sorted Sets 通常用于索引Redis中存储的数据。例如，如果您有许多代表用户的哈希，则可以使用已排序的集合，其元素具有用户的年龄作为得分，而用户的ID作为值。因此，使用ZRANGEBYSCORE检索具有给定年龄段的所有用户将非常简单快捷。</p>
</li>
<li>
<p>Sorted Set 还可用作为延迟队列，使用 时间戳 作为score， ZRANGEBYSCORE 来查找符合时间范围的数据，并且再消费完成以后，使用 ZREMRANGEBYSCORE 来删除这部分数据</p>
</li>
</ul>
<h2 id="bitmaps">Bitmaps</h2>
<p>Bitmaps and HyperLogLogs 实际上是基于 String 类型，但是他们有自己的语意</p>
<p>Bitmaps 支持如下几个操作：<br/>
BITCOUNT BITFIELD BITOP BITPOS GETBIT and SETBIT</p>
<p>Bitmaps 是某些类型信息的非常节省空间的表示形式。
一个示例是需要用户访问历史的Web应用程序，因此例如可以确定哪些用户是beta功能的良好目标。</p>
<p>使用场景：</p>
<ul>
<li>制作快速，简便，实时的指标</li>
<li>每日活跃用户，每日一个key，根据用户ID对 redis key 的偏移位进行置1，</li>
<li></li>
</ul>
<h2 id="hyperloglogs">HyperLogLogs</h2>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>类似 set 计算值基数集的数量，但是不能返回具体的元素。</p>
<p>一边 ADD 一边计算， 所以在使用 PFCOUNT 的时候，只是取一个值，并未进行计算所以复杂度是 O(1)</p>
<p>当用单个键调用PFCOUNT时，即使在理论上处理密集型HyperLogLog的恒定时间很高，性能也很出色。这是可能的，因为PFCOUNT使用缓存来记住先前计算的基数，这种变化很少改变，因为大多数PFADD操作不会更新任何寄存器。每秒可能进行数百次操作。</p>
<p>当使用多个键调用PFCOUNT时，会执行HyperLogLogs的即时合并，这很慢，而且无法缓存联合的基数，因此当与多个键一起使用时，PFCOUNT可能会花费一些时间。一个毫秒级的数量级，不应滥用。</p>
<p>用户应记住，PFCOUNT 命令的单key和多keys执行在语义上是不同的，并且具有不同的性能。</p>
<p>更多数据类型的用法请前往官网查看更多消息 <a href="https://redis.io/commands">https://redis.io/commands</a></p><p></p>
</article>


<script src=""></script>


<script src=""></script>


 

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
  
  <div class="book-comments">

</div>
  
 
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#数据类型">数据类型</a>
      <ul>
        <li><a href="#strings">Strings</a></li>
        <li><a href="#lists">Lists</a></li>
        <li><a href="#sets">Sets</a></li>
        <li><a href="#hashes">Hashes</a></li>
        <li><a href="#sorted-sets">Sorted sets</a></li>
        <li><a href="#bitmaps">Bitmaps</a></li>
        <li><a href="#hyperloglogs">HyperLogLogs</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  

  <script src="/js/audiojs/audio.min.js"></script>
  <script src="/js/audiojs/custom.js"></script>















</body></html>